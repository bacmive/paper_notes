 --- modulename: gener, funcname: <module>
gener.py(3): import re
gener.py(4): import logging
gener.py(6): from copy import deepcopy
gener.py(9): class TypeDef(object):
 --- modulename: gener, funcname: TypeDef
gener.py(9): class TypeDef(object):
gener.py(10):     def __init__(self, text):
gener.py(19):     def evalEnum(self, text):
gener.py(31):     def evalScalarset(self, text):
gener.py(44):     def evalBool(self):
gener.py(49):     def evaluate(self, text):
gener.py(65): index = -1
gener.py(67): class Record(object):
 --- modulename: gener, funcname: Record
gener.py(67): class Record(object):
gener.py(68):     def __init__(self, text, typenames):
gener.py(73):     def judgeRecord(self, n, p, v):
gener.py(79):     def handleArr(self, n, v):
gener.py(101):     def evaluate(self, text):
gener.py(128): class Vardef(object):
 --- modulename: gener, funcname: Vardef
gener.py(128): class Vardef(object):
gener.py(129):     def __init__(self, text, typenames):
gener.py(134):     def judgeRecord(self, n, p, v):
gener.py(140):     def handleArr(self, n, v):
gener.py(150):     def evaluate(self, text):
gener.py(178): def analyzeParams(params):
gener.py(197): def escape(name):
gener.py(207): class Formula(object):
 --- modulename: gener, funcname: Formula
gener.py(207): class Formula(object):
gener.py(208):     __PRIORITY = {
gener.py(209):         '(': 100, '=': 50, '!=': 50, '!': 40, '&': 30, '|': 20, '->': 10
gener.py(211):     def __init__(self, text, param_names, consts):
gener.py(224):     def splitText(self, text):
gener.py(250):     def process(self, text):
gener.py(268):     def evalVar(self, var):
gener.py(288):     def evalAtom(self, atom, param_names):
gener.py(314):     __RELATION_OP = {
gener.py(315):         '&': '(andList [%s; %s])',
gener.py(316):         '|': '(orList [%s; %s])',
gener.py(317):         '->': '(imply %s %s)',
gener.py(318):         '=': '(eqn %s %s)',
gener.py(319):         '!=': '(neg (eqn %s %s))',
gener.py(321):     def evaluate(self, suffix, param_names):
gener.py(371): class Statement(object):
 --- modulename: gener, funcname: Statement
gener.py(371): class Statement(object):
gener.py(372):     def __init__(self, text, param_names, consts):
gener.py(379):     def splitText(self, text):
gener.py(403):     def evalVar(self, var):
gener.py(423):     def evalAtom(self, atom, param_names):
gener.py(435):     def partitionIf(self, statement):
gener.py(460):     def analyzeIf(self, sub_clause, param_names, consts):
gener.py(478):     def evalIf(self, statement, param_names, consts):
gener.py(500):     def evalFor(self, statement, param_names, consts):
gener.py(508):     def evaluate(self, statements, param_names, consts):
gener.py(556): class Rule(object):
 --- modulename: gener, funcname: Rule
gener.py(556): class Rule(object):
gener.py(557):     def __init__(self, text, params, param_names, consts):
gener.py(596): class RuleSet(object):
 --- modulename: gener, funcname: RuleSet
gener.py(596): class RuleSet(object):
gener.py(597):     def __init__(self, text, consts):
gener.py(607):     def rulesets(self, text, consts):
gener.py(617):     def singlerules(self, text, consts, ruleset_names):
gener.py(633): class StartState(object):
 --- modulename: gener, funcname: StartState
gener.py(633): class StartState(object):
gener.py(634):     def __init__(self, text, consts, typenames):
gener.py(666): class Invariant(object):
 --- modulename: gener, funcname: Invariant
gener.py(666): class Invariant(object):
gener.py(667):     def __init__(self, text, consts, typenames):
gener.py(679):     def invsets(self, text, consts):
gener.py(696):     def inv_alone(self, text, consts):
gener.py(723): class Protocol(object):
 --- modulename: gener, funcname: Protocol
gener.py(723): class Protocol(object):
gener.py(724):     def __init__(self, name, filename):
gener.py(731):     def evaluate(self):
gener.py(765): if __name__ == '__main__':
gener.py(766):     murphi = "mutualEx.m"
gener.py(767):     name = "mutualEx"
gener.py(768):     protocol = Protocol(name, murphi)
 --- modulename: gener, funcname: __init__
gener.py(725):         self.name = escape(name)
 --- modulename: gener, funcname: escape
gener.py(198):     return 'n_%s'%(re.sub(r'_+', '_', re.sub(r'[^a-zA-Z0-9]', '_', name).strip('_')))
gener.py(726):         f = open(filename, 'r')
gener.py(727):         self.content = f.read()
gener.py(728):         f.close()
gener.py(729):         self.evaluate()
 --- modulename: gener, funcname: evaluate
gener.py(732):         types = TypeDef(self.content)
 --- modulename: gener, funcname: __init__
gener.py(12):         self.consts = {}
gener.py(13):         self.const_defs = []
gener.py(14):         self.typedefs = []
gener.py(16):         self.typenames = {}
gener.py(17):         self.evaluate(text)
 --- modulename: gener, funcname: evaluate
gener.py(50):         self.evalEnum(text)
 --- modulename: gener, funcname: evalEnum
gener.py(20):         enums = re.findall(r'(\w*?)\s*:\s*enum\s*\{(.*?)\}\s*;', text, re.S)
gener.py(21):         for name, vstr in enums:
gener.py(22):             values = filter(lambda x: x, map(lambda y: y.strip(), vstr.split(',')))
 --- modulename: gener, funcname: <lambda>
gener.py(22):             values = filter(lambda x: x, map(lambda y: y.strip(), vstr.split(',')))
 --- modulename: gener, funcname: <lambda>
gener.py(22):             values = filter(lambda x: x, map(lambda y: y.strip(), vstr.split(',')))
 --- modulename: gener, funcname: <lambda>
gener.py(22):             values = filter(lambda x: x, map(lambda y: y.strip(), vstr.split(',')))
 --- modulename: gener, funcname: <lambda>
gener.py(22):             values = filter(lambda x: x, map(lambda y: y.strip(), vstr.split(',')))
 --- modulename: gener, funcname: <lambda>
gener.py(22):             values = filter(lambda x: x, map(lambda y: y.strip(), vstr.split(',')))
 --- modulename: gener, funcname: <lambda>
gener.py(22):             values = filter(lambda x: x, map(lambda y: y.strip(), vstr.split(',')))
 --- modulename: gener, funcname: <lambda>
gener.py(22):             values = filter(lambda x: x, map(lambda y: y.strip(), vstr.split(',')))
 --- modulename: gener, funcname: <lambda>
gener.py(22):             values = filter(lambda x: x, map(lambda y: y.strip(), vstr.split(',')))
gener.py(23):             for v in values: self.consts[v] = 0
gener.py(23):             for v in values: self.consts[v] = 0
gener.py(23):             for v in values: self.consts[v] = 0
gener.py(23):             for v in values: self.consts[v] = 0
gener.py(23):             for v in values: self.consts[v] = 0
gener.py(24):             self.const_defs += map(lambda v: 'let _%s = strc \"%s\"'%(v, v), values)
 --- modulename: gener, funcname: <lambda>
gener.py(24):             self.const_defs += map(lambda v: 'let _%s = strc \"%s\"'%(v, v), values)
 --- modulename: gener, funcname: <lambda>
gener.py(24):             self.const_defs += map(lambda v: 'let _%s = strc \"%s\"'%(v, v), values)
 --- modulename: gener, funcname: <lambda>
gener.py(24):             self.const_defs += map(lambda v: 'let _%s = strc \"%s\"'%(v, v), values)
 --- modulename: gener, funcname: <lambda>
gener.py(24):             self.const_defs += map(lambda v: 'let _%s = strc \"%s\"'%(v, v), values)
gener.py(25):             self.typedefs.append('enum \"%s\" [%s];'%(
gener.py(26):                 name, 
gener.py(27):                 '; '.join(map(lambda x: '_%s'%x, values))
 --- modulename: gener, funcname: <lambda>
gener.py(27):                 '; '.join(map(lambda x: '_%s'%x, values))
 --- modulename: gener, funcname: <lambda>
gener.py(27):                 '; '.join(map(lambda x: '_%s'%x, values))
 --- modulename: gener, funcname: <lambda>
gener.py(27):                 '; '.join(map(lambda x: '_%s'%x, values))
 --- modulename: gener, funcname: <lambda>
gener.py(27):                 '; '.join(map(lambda x: '_%s'%x, values))
gener.py(29):             self.typenames[name] = map(lambda x: '_%s'%x, values)
 --- modulename: gener, funcname: <lambda>
gener.py(29):             self.typenames[name] = map(lambda x: '_%s'%x, values)
 --- modulename: gener, funcname: <lambda>
gener.py(29):             self.typenames[name] = map(lambda x: '_%s'%x, values)
 --- modulename: gener, funcname: <lambda>
gener.py(29):             self.typenames[name] = map(lambda x: '_%s'%x, values)
 --- modulename: gener, funcname: <lambda>
gener.py(29):             self.typenames[name] = map(lambda x: '_%s'%x, values)
gener.py(21):         for name, vstr in enums:
gener.py(51):         self.evalScalarset(text)
 --- modulename: gener, funcname: evalScalarset
gener.py(32):         scalarsets = re.findall(r'(\w*?)\s*:\s*(\w+?)\s*\.\.\s*(\w+?)\s*;', text, re.S)
gener.py(33):         def const2num(v, text):
gener.py(35):         for name, v1, v2 in scalarsets:
gener.py(36):             num1 = int(v1) if re.match(r'\d+', v1) else const2num(v1, text)
gener.py(37):             num2 = int(v2) if re.match(r'\d+', v2) else const2num(v2, text)
 --- modulename: gener, funcname: const2num
gener.py(34):             return int(re.findall(r'%s\s*:\s*(\d+)\s*;'%v, text, re.S)[0])
gener.py(38):             self.typedefs.append('enum \"%s\" (int_consts [%s]);'%(
gener.py(39):                 name,
gener.py(40):                 '; '.join(map(lambda x: str(x), range(num1, num2 + 1)))
 --- modulename: gener, funcname: <lambda>
gener.py(40):                 '; '.join(map(lambda x: str(x), range(num1, num2 + 1)))
 --- modulename: gener, funcname: <lambda>
gener.py(40):                 '; '.join(map(lambda x: str(x), range(num1, num2 + 1)))
gener.py(42):             self.typenames[name] = map(lambda x: '(intc %d)'%x, range(num1, num2 + 1))
 --- modulename: gener, funcname: <lambda>
gener.py(42):             self.typenames[name] = map(lambda x: '(intc %d)'%x, range(num1, num2 + 1))
 --- modulename: gener, funcname: <lambda>
gener.py(42):             self.typenames[name] = map(lambda x: '(intc %d)'%x, range(num1, num2 + 1))
gener.py(35):         for name, v1, v2 in scalarsets:
gener.py(52):         self.evalBool()
 --- modulename: gener, funcname: evalBool
gener.py(45):         self.const_defs += ['let _True = boolc true', 'let _False = boolc false']
gener.py(46):         self.typedefs.append('enum "boolean" [_True; _False];')
gener.py(47):         self.typenames['boolean'] = ['_False', '_True'];
gener.py(53):         self.value = '%s\n\n%s'%(
gener.py(54):             '\n'.join(self.const_defs),
gener.py(55):             'let types = [\n%s\n]'%('\n'.join(map(lambda x: '  %s'%x, self.typedefs)))
 --- modulename: gener, funcname: <lambda>
gener.py(55):             'let types = [\n%s\n]'%('\n'.join(map(lambda x: '  %s'%x, self.typedefs)))
 --- modulename: gener, funcname: <lambda>
gener.py(55):             'let types = [\n%s\n]'%('\n'.join(map(lambda x: '  %s'%x, self.typedefs)))
 --- modulename: gener, funcname: <lambda>
gener.py(55):             'let types = [\n%s\n]'%('\n'.join(map(lambda x: '  %s'%x, self.typedefs)))
gener.py(733):         records = Record(self.content, types.typenames)
 --- modulename: gener, funcname: __init__
gener.py(69):         super(Record, self).__init__()
gener.py(70):         self.typenames = typenames
gener.py(71):         self.evaluate(text)
 --- modulename: gener, funcname: evaluate
gener.py(102):         records = []
gener.py(103):         record_strs = re.findall(r'(\w*?)\s*:\s*record\s*(.+?)\s*end\s*;', text, re.S)
gener.py(104):         for name, fields in record_strs:
gener.py(115):         self.value = '\n\n'.join(records)
gener.py(734):         vardefs = Vardef(self.content, types.typenames)
 --- modulename: gener, funcname: __init__
gener.py(130):         super(Vardef, self).__init__()
gener.py(131):         self.typenames = typenames
gener.py(132):         self.evaluate(text)
 --- modulename: gener, funcname: evaluate
gener.py(151):         vs = []
gener.py(152):         var_str = re.findall(r'var\s+((?:\w*\s*:\s*.*?\s*;\s*)*)', text, re.S)[0]
gener.py(153):         fields = map(
gener.py(154):             lambda x: tuple(map(lambda y: y.strip(), x.split(':'))), 
gener.py(155):             filter(lambda x: x.strip(), var_str.split(';'))
 --- modulename: gener, funcname: <lambda>
gener.py(155):             filter(lambda x: x.strip(), var_str.split(';'))
 --- modulename: gener, funcname: <lambda>
gener.py(155):             filter(lambda x: x.strip(), var_str.split(';'))
 --- modulename: gener, funcname: <lambda>
gener.py(155):             filter(lambda x: x.strip(), var_str.split(';'))
 --- modulename: gener, funcname: <lambda>
gener.py(154):             lambda x: tuple(map(lambda y: y.strip(), x.split(':'))), 
 --- modulename: gener, funcname: <lambda>
gener.py(154):             lambda x: tuple(map(lambda y: y.strip(), x.split(':'))), 
 --- modulename: gener, funcname: <lambda>
gener.py(154):             lambda x: tuple(map(lambda y: y.strip(), x.split(':'))), 
 --- modulename: gener, funcname: <lambda>
gener.py(154):             lambda x: tuple(map(lambda y: y.strip(), x.split(':'))), 
 --- modulename: gener, funcname: <lambda>
gener.py(154):             lambda x: tuple(map(lambda y: y.strip(), x.split(':'))), 
 --- modulename: gener, funcname: <lambda>
gener.py(154):             lambda x: tuple(map(lambda y: y.strip(), x.split(':'))), 
gener.py(157):         values = map(
gener.py(158):             lambda (name, t): self.handleArr(name, t),
gener.py(159):             fields
 --- modulename: gener, funcname: <lambda>
gener.py(158):             lambda (name, t): self.handleArr(name, t),
 --- modulename: gener, funcname: handleArr
gener.py(141):         if v[:5] == 'array':
gener.py(143):             pattern = re.compile(r'array\s*\[(.+)\]\s*of\s*(.+)')
gener.py(144):             param, t = pattern.findall(v)[0]
gener.py(145):             index += 1
gener.py(146):             return self.judgeRecord(n, '[paramdef \"i%d\" \"%s\"]'%(index, param), t)
 --- modulename: gener, funcname: judgeRecord
gener.py(135):         if v in self.typenames:
gener.py(136):             return '  [arrdef [(\"%s\", %s)] \"%s\"]'%(n, p, v)
 --- modulename: gener, funcname: <lambda>
gener.py(158):             lambda (name, t): self.handleArr(name, t),
 --- modulename: gener, funcname: handleArr
gener.py(141):         if v[:5] == 'array':
gener.py(148):             return self.judgeRecord(n, '[]', v)
 --- modulename: gener, funcname: judgeRecord
gener.py(135):         if v in self.typenames:
gener.py(136):             return '  [arrdef [(\"%s\", %s)] \"%s\"]'%(n, p, v)
gener.py(161):         self.value = 'let vardefs = List.concat [\n%s\n]'%(';\n'.join(values))
gener.py(735):         init = StartState(self.content, types.consts, types.typenames)
 --- modulename: gener, funcname: __init__
gener.py(635):         super(StartState, self).__init__()
gener.py(636):         init_p2 = r'startstate\s*(?:\".*?\"){0,1}(?:.*?begin){0,1}(.*?)endstartstate\s*;'
gener.py(637):         init_p1 = r'ruleset\s*([\w :;]*)do\s*%s\s*endruleset\s*;'%init_p2
gener.py(638):         if re.findall(init_p1, text, re.S):
gener.py(641):             params, statements = '', re.findall(init_p2, text, re.S)[0]
gener.py(642):         param_types, _ = analyzeParams(params)
 --- modulename: gener, funcname: analyzeParams
gener.py(183):     if not params:
gener.py(184):         return {}, '[]'
gener.py(643):         for k, v in param_types.items():
gener.py(645):         statement = Statement(statements, param_types, consts)
 --- modulename: gener, funcname: __init__
gener.py(373):         super(Statement, self).__init__()
gener.py(374):         self.param_names = param_names
gener.py(375):         self.consts = consts
gener.py(376):         self.statements = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
gener.py(381):         big_parts = []
gener.py(382):         to_add = []
gener.py(383):         exp_ends = 0
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(386):                 exp_ends += 1
gener.py(387):                 to_add.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(395):                 to_add.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(395):                 to_add.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(395):                 to_add.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(389):                 exp_ends -= 1
gener.py(390):                 to_add.append(p)
gener.py(391):                 if exp_ends == 0:
gener.py(392):                     big_parts.append(' '.join(to_add))
gener.py(393):                     to_add = []
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(398):         if len(big_parts) == 0:
gener.py(401):         return big_parts
gener.py(377):         self.value = self.evaluate(self.statements, self.param_names, self.consts)
 --- modulename: gener, funcname: evaluate
gener.py(509):         def inner(statement):
gener.py(528):         if len(statements) > 1:
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: <lambda>
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(513):                 return self.evalFor(statement, param_names, consts)
 --- modulename: gener, funcname: evalFor
gener.py(501):         params, statement_str = re.findall(r'for(.*?)do(.*)end(?:for)*', statement, re.S)[0]
gener.py(502):         param_name_dict, param_defs = analyzeParams(params)
 --- modulename: gener, funcname: analyzeParams
gener.py(183):     if not params:
gener.py(185):     parts = params.split(';')
gener.py(186):     param_name_dict = {}
gener.py(187):     for p in parts: param_name_dict[p.split(':')[0].strip()] = p.split(':')[1].strip()
gener.py(187):     for p in parts: param_name_dict[p.split(':')[0].strip()] = p.split(':')[1].strip()
gener.py(188):     param_defs = map(
gener.py(189):         lambda x: 'paramdef ' + ' '.join(map(
gener.py(193):         parts
 --- modulename: gener, funcname: <lambda>
gener.py(189):         lambda x: 'paramdef ' + ' '.join(map(
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
gener.py(191):             x.strip().split(':'))
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
gener.py(195):     return param_name_dict, '[%s]'%('; '.join(param_defs))
gener.py(503):         for p in param_names:
gener.py(505):         inner_ss = self.evaluate(self.splitText(statement_str), param_name_dict, consts)
 --- modulename: gener, funcname: splitText
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
gener.py(381):         big_parts = []
gener.py(382):         to_add = []
gener.py(383):         exp_ends = 0
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(398):         if len(big_parts) == 0:
gener.py(401):         return big_parts
 --- modulename: gener, funcname: evaluate
gener.py(509):         def inner(statement):
gener.py(528):         if len(statements) > 1:
gener.py(530):         elif len(statements) == 1:
gener.py(531):             return inner(statements[0])
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(415):                 'arr [(\"%s\", [%s])]' %(
gener.py(416):                     parts[0], 
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(425):             return '(const _%s)'%atom
gener.py(525):                     return '(assign %s %s)'%(v, e)
gener.py(506):         return '(forStatement %s %s)'%(inner_ss, param_defs)
 --- modulename: gener, funcname: <lambda>
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(426):         elif atom in param_names:
gener.py(428):         elif re.match(r'^\d+$', atom):
gener.py(430):         elif atom.lower() in ['true', 'false']:
gener.py(431):             return '(const (boolc %s))'%atom.lower()
gener.py(525):                     return '(assign %s %s)'%(v, e)
gener.py(646):         statement_value = statement.value
gener.py(647):         for k, v in param_types.items():
gener.py(652):         self.value = 'let init = %s'%statement_value
gener.py(736):         rulesets = RuleSet(self.content, types.consts)
 --- modulename: gener, funcname: __init__
gener.py(598):         super(RuleSet, self).__init__()
gener.py(599):         rules = []
gener.py(600):         rules += self.rulesets(text, consts)
 --- modulename: gener, funcname: rulesets
gener.py(608):         rules = []
gener.py(609):         pattern = re.compile(r'ruleset(.*?)do(.*?)endruleset\s*;', re.S)
gener.py(610):         rulesets = pattern.findall(text)
gener.py(611):         for params, rules_str in rulesets:
gener.py(612):             param_name_dict, param_defs = analyzeParams(params)
 --- modulename: gener, funcname: analyzeParams
gener.py(183):     if not params:
gener.py(185):     parts = params.split(';')
gener.py(186):     param_name_dict = {}
gener.py(187):     for p in parts: param_name_dict[p.split(':')[0].strip()] = p.split(':')[1].strip()
gener.py(187):     for p in parts: param_name_dict[p.split(':')[0].strip()] = p.split(':')[1].strip()
gener.py(188):     param_defs = map(
gener.py(189):         lambda x: 'paramdef ' + ' '.join(map(
gener.py(193):         parts
 --- modulename: gener, funcname: <lambda>
gener.py(189):         lambda x: 'paramdef ' + ' '.join(map(
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
gener.py(191):             x.strip().split(':'))
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
gener.py(195):     return param_name_dict, '[%s]'%('; '.join(param_defs))
gener.py(613):             rule_texts = re.findall(r'(rule.*?endrule;)', rules_str, re.S)
gener.py(614):             rules += map(lambda r: Rule(r, param_defs, param_name_dict, consts), rule_texts)
 --- modulename: gener, funcname: <lambda>
gener.py(614):             rules += map(lambda r: Rule(r, param_defs, param_name_dict, consts), rule_texts)
 --- modulename: gener, funcname: __init__
gener.py(558):         super(Rule, self).__init__()
gener.py(559):         pattern = re.compile(r'rule\s*\"(.*?)\"\s*(.*?)==>.*?begin(.*?)endrule\s*;', re.S)
gener.py(560):         self.name, guard, statements = pattern.findall(text)[0]
gener.py(561):         self.name = escape(self.name)
 --- modulename: gener, funcname: escape
gener.py(198):     return 'n_%s'%(re.sub(r'_+', '_', re.sub(r'[^a-zA-Z0-9]', '_', name).strip('_')))
gener.py(562):         self.params = params
gener.py(563):         self.param_names = param_names
gener.py(564):         self.formula = Formula(guard, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(212):         super(Formula, self).__init__()
gener.py(213):         self.param_names = param_names
gener.py(214):         self.consts = consts
gener.py(215):         try:
gener.py(216):             self.text = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(225):         dividers = r'(do|\sendforall|\sendexists|\send|\(|\)|=|!=|!|&|\||->)'
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
gener.py(227):         big_parts = []
gener.py(228):         to_add = []
gener.py(229):         exp_ends = 0
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(244):         if len(big_parts) == 0:
gener.py(248):         return big_parts
gener.py(217):             self.suffix = self.process(self.text)
 --- modulename: gener, funcname: process
gener.py(251):         ops = []
gener.py(252):         suffix = []
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(266):         return suffix
gener.py(218):             self.value = self.evaluate(self.suffix, self.param_names)
 --- modulename: gener, funcname: evaluate
gener.py(322):         values = []
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(350):         if values[0][0]: return values[0][1]
gener.py(565):         self.statement = Statement(statements, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(373):         super(Statement, self).__init__()
gener.py(374):         self.param_names = param_names
gener.py(375):         self.consts = consts
gener.py(376):         self.statements = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
gener.py(381):         big_parts = []
gener.py(382):         to_add = []
gener.py(383):         exp_ends = 0
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(398):         if len(big_parts) == 0:
gener.py(401):         return big_parts
gener.py(377):         self.value = self.evaluate(self.statements, self.param_names, self.consts)
 --- modulename: gener, funcname: evaluate
gener.py(509):         def inner(statement):
gener.py(528):         if len(statements) > 1:
gener.py(530):         elif len(statements) == 1:
gener.py(531):             return inner(statements[0])
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(415):                 'arr [(\"%s\", [%s])]' %(
gener.py(416):                     parts[0], 
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(425):             return '(const _%s)'%atom
gener.py(525):                     return '(assign %s %s)'%(v, e)
gener.py(571):   rule name params formula statement'''%(self.name, self.name, self.params, self.formula.value, self.statement.value)
 --- modulename: gener, funcname: <lambda>
gener.py(614):             rules += map(lambda r: Rule(r, param_defs, param_name_dict, consts), rule_texts)
 --- modulename: gener, funcname: __init__
gener.py(558):         super(Rule, self).__init__()
gener.py(559):         pattern = re.compile(r'rule\s*\"(.*?)\"\s*(.*?)==>.*?begin(.*?)endrule\s*;', re.S)
gener.py(560):         self.name, guard, statements = pattern.findall(text)[0]
gener.py(561):         self.name = escape(self.name)
 --- modulename: gener, funcname: escape
gener.py(198):     return 'n_%s'%(re.sub(r'_+', '_', re.sub(r'[^a-zA-Z0-9]', '_', name).strip('_')))
gener.py(562):         self.params = params
gener.py(563):         self.param_names = param_names
gener.py(564):         self.formula = Formula(guard, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(212):         super(Formula, self).__init__()
gener.py(213):         self.param_names = param_names
gener.py(214):         self.consts = consts
gener.py(215):         try:
gener.py(216):             self.text = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(225):         dividers = r'(do|\sendforall|\sendexists|\send|\(|\)|=|!=|!|&|\||->)'
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
gener.py(227):         big_parts = []
gener.py(228):         to_add = []
gener.py(229):         exp_ends = 0
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(244):         if len(big_parts) == 0:
gener.py(248):         return big_parts
gener.py(217):             self.suffix = self.process(self.text)
 --- modulename: gener, funcname: process
gener.py(251):         ops = []
gener.py(252):         suffix = []
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(256):                     suffix.append(ops.pop())
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(266):         return suffix
gener.py(218):             self.value = self.evaluate(self.suffix, self.param_names)
 --- modulename: gener, funcname: evaluate
gener.py(322):         values = []
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(296):             return '(const (boolc %s))'%atom.lower()
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(330):             elif s == '!':
gener.py(337):             elif s in ['&', '|', '->']:
gener.py(338):                 def do_eval(evaled, atom):
gener.py(343):                 rval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(344):                 lval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(345):                 values.append((True, self.__RELATION_OP[s]%(lval, rval)))
gener.py(323):         for s in suffix:
gener.py(350):         if values[0][0]: return values[0][1]
gener.py(565):         self.statement = Statement(statements, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(373):         super(Statement, self).__init__()
gener.py(374):         self.param_names = param_names
gener.py(375):         self.consts = consts
gener.py(376):         self.statements = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
gener.py(381):         big_parts = []
gener.py(382):         to_add = []
gener.py(383):         exp_ends = 0
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(398):         if len(big_parts) == 0:
gener.py(401):         return big_parts
gener.py(377):         self.value = self.evaluate(self.statements, self.param_names, self.consts)
 --- modulename: gener, funcname: evaluate
gener.py(509):         def inner(statement):
gener.py(528):         if len(statements) > 1:
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: <lambda>
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(415):                 'arr [(\"%s\", [%s])]' %(
gener.py(416):                     parts[0], 
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(425):             return '(const _%s)'%atom
gener.py(525):                     return '(assign %s %s)'%(v, e)
 --- modulename: gener, funcname: <lambda>
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(426):         elif atom in param_names:
gener.py(428):         elif re.match(r'^\d+$', atom):
gener.py(430):         elif atom.lower() in ['true', 'false']:
gener.py(431):             return '(const (boolc %s))'%atom.lower()
gener.py(525):                     return '(assign %s %s)'%(v, e)
gener.py(571):   rule name params formula statement'''%(self.name, self.name, self.params, self.formula.value, self.statement.value)
 --- modulename: gener, funcname: <lambda>
gener.py(614):             rules += map(lambda r: Rule(r, param_defs, param_name_dict, consts), rule_texts)
 --- modulename: gener, funcname: __init__
gener.py(558):         super(Rule, self).__init__()
gener.py(559):         pattern = re.compile(r'rule\s*\"(.*?)\"\s*(.*?)==>.*?begin(.*?)endrule\s*;', re.S)
gener.py(560):         self.name, guard, statements = pattern.findall(text)[0]
gener.py(561):         self.name = escape(self.name)
 --- modulename: gener, funcname: escape
gener.py(198):     return 'n_%s'%(re.sub(r'_+', '_', re.sub(r'[^a-zA-Z0-9]', '_', name).strip('_')))
gener.py(562):         self.params = params
gener.py(563):         self.param_names = param_names
gener.py(564):         self.formula = Formula(guard, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(212):         super(Formula, self).__init__()
gener.py(213):         self.param_names = param_names
gener.py(214):         self.consts = consts
gener.py(215):         try:
gener.py(216):             self.text = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(225):         dividers = r'(do|\sendforall|\sendexists|\send|\(|\)|=|!=|!|&|\||->)'
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
gener.py(227):         big_parts = []
gener.py(228):         to_add = []
gener.py(229):         exp_ends = 0
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(244):         if len(big_parts) == 0:
gener.py(248):         return big_parts
gener.py(217):             self.suffix = self.process(self.text)
 --- modulename: gener, funcname: process
gener.py(251):         ops = []
gener.py(252):         suffix = []
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(266):         return suffix
gener.py(218):             self.value = self.evaluate(self.suffix, self.param_names)
 --- modulename: gener, funcname: evaluate
gener.py(322):         values = []
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(350):         if values[0][0]: return values[0][1]
gener.py(565):         self.statement = Statement(statements, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(373):         super(Statement, self).__init__()
gener.py(374):         self.param_names = param_names
gener.py(375):         self.consts = consts
gener.py(376):         self.statements = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
gener.py(381):         big_parts = []
gener.py(382):         to_add = []
gener.py(383):         exp_ends = 0
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(398):         if len(big_parts) == 0:
gener.py(401):         return big_parts
gener.py(377):         self.value = self.evaluate(self.statements, self.param_names, self.consts)
 --- modulename: gener, funcname: evaluate
gener.py(509):         def inner(statement):
gener.py(528):         if len(statements) > 1:
gener.py(530):         elif len(statements) == 1:
gener.py(531):             return inner(statements[0])
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(415):                 'arr [(\"%s\", [%s])]' %(
gener.py(416):                     parts[0], 
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(425):             return '(const _%s)'%atom
gener.py(525):                     return '(assign %s %s)'%(v, e)
gener.py(571):   rule name params formula statement'''%(self.name, self.name, self.params, self.formula.value, self.statement.value)
 --- modulename: gener, funcname: <lambda>
gener.py(614):             rules += map(lambda r: Rule(r, param_defs, param_name_dict, consts), rule_texts)
 --- modulename: gener, funcname: __init__
gener.py(558):         super(Rule, self).__init__()
gener.py(559):         pattern = re.compile(r'rule\s*\"(.*?)\"\s*(.*?)==>.*?begin(.*?)endrule\s*;', re.S)
gener.py(560):         self.name, guard, statements = pattern.findall(text)[0]
gener.py(561):         self.name = escape(self.name)
 --- modulename: gener, funcname: escape
gener.py(198):     return 'n_%s'%(re.sub(r'_+', '_', re.sub(r'[^a-zA-Z0-9]', '_', name).strip('_')))
gener.py(562):         self.params = params
gener.py(563):         self.param_names = param_names
gener.py(564):         self.formula = Formula(guard, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(212):         super(Formula, self).__init__()
gener.py(213):         self.param_names = param_names
gener.py(214):         self.consts = consts
gener.py(215):         try:
gener.py(216):             self.text = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(225):         dividers = r'(do|\sendforall|\sendexists|\send|\(|\)|=|!=|!|&|\||->)'
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
gener.py(227):         big_parts = []
gener.py(228):         to_add = []
gener.py(229):         exp_ends = 0
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(244):         if len(big_parts) == 0:
gener.py(248):         return big_parts
gener.py(217):             self.suffix = self.process(self.text)
 --- modulename: gener, funcname: process
gener.py(251):         ops = []
gener.py(252):         suffix = []
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(266):         return suffix
gener.py(218):             self.value = self.evaluate(self.suffix, self.param_names)
 --- modulename: gener, funcname: evaluate
gener.py(322):         values = []
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(350):         if values[0][0]: return values[0][1]
gener.py(565):         self.statement = Statement(statements, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(373):         super(Statement, self).__init__()
gener.py(374):         self.param_names = param_names
gener.py(375):         self.consts = consts
gener.py(376):         self.statements = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
gener.py(381):         big_parts = []
gener.py(382):         to_add = []
gener.py(383):         exp_ends = 0
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(398):         if len(big_parts) == 0:
gener.py(401):         return big_parts
gener.py(377):         self.value = self.evaluate(self.statements, self.param_names, self.consts)
 --- modulename: gener, funcname: evaluate
gener.py(509):         def inner(statement):
gener.py(528):         if len(statements) > 1:
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: <lambda>
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(415):                 'arr [(\"%s\", [%s])]' %(
gener.py(416):                     parts[0], 
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(425):             return '(const _%s)'%atom
gener.py(525):                     return '(assign %s %s)'%(v, e)
 --- modulename: gener, funcname: <lambda>
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(426):         elif atom in param_names:
gener.py(428):         elif re.match(r'^\d+$', atom):
gener.py(430):         elif atom.lower() in ['true', 'false']:
gener.py(431):             return '(const (boolc %s))'%atom.lower()
gener.py(525):                     return '(assign %s %s)'%(v, e)
gener.py(571):   rule name params formula statement'''%(self.name, self.name, self.params, self.formula.value, self.statement.value)
gener.py(611):         for params, rules_str in rulesets:
gener.py(612):             param_name_dict, param_defs = analyzeParams(params)
 --- modulename: gener, funcname: analyzeParams
gener.py(183):     if not params:
gener.py(185):     parts = params.split(';')
gener.py(186):     param_name_dict = {}
gener.py(187):     for p in parts: param_name_dict[p.split(':')[0].strip()] = p.split(':')[1].strip()
gener.py(187):     for p in parts: param_name_dict[p.split(':')[0].strip()] = p.split(':')[1].strip()
gener.py(187):     for p in parts: param_name_dict[p.split(':')[0].strip()] = p.split(':')[1].strip()
gener.py(188):     param_defs = map(
gener.py(189):         lambda x: 'paramdef ' + ' '.join(map(
gener.py(193):         parts
 --- modulename: gener, funcname: <lambda>
gener.py(189):         lambda x: 'paramdef ' + ' '.join(map(
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
gener.py(191):             x.strip().split(':'))
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
 --- modulename: gener, funcname: <lambda>
gener.py(189):         lambda x: 'paramdef ' + ' '.join(map(
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
gener.py(191):             x.strip().split(':'))
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
gener.py(195):     return param_name_dict, '[%s]'%('; '.join(param_defs))
gener.py(613):             rule_texts = re.findall(r'(rule.*?endrule;)', rules_str, re.S)
gener.py(614):             rules += map(lambda r: Rule(r, param_defs, param_name_dict, consts), rule_texts)
gener.py(611):         for params, rules_str in rulesets:
gener.py(615):         return rules
gener.py(601):         rules += self.singlerules(text, consts, map(lambda r: r.name, rules))
 --- modulename: gener, funcname: <lambda>
gener.py(601):         rules += self.singlerules(text, consts, map(lambda r: r.name, rules))
 --- modulename: gener, funcname: <lambda>
gener.py(601):         rules += self.singlerules(text, consts, map(lambda r: r.name, rules))
 --- modulename: gener, funcname: <lambda>
gener.py(601):         rules += self.singlerules(text, consts, map(lambda r: r.name, rules))
 --- modulename: gener, funcname: <lambda>
gener.py(601):         rules += self.singlerules(text, consts, map(lambda r: r.name, rules))
 --- modulename: gener, funcname: singlerules
gener.py(618):         pattern = re.compile(r'(rule.*?endrule\s*;)', re.S)
gener.py(619):         rule_texts = pattern.findall(text)
gener.py(620):         rules = map(lambda r: Rule(r, [], {}, consts), rule_texts)
 --- modulename: gener, funcname: <lambda>
gener.py(620):         rules = map(lambda r: Rule(r, [], {}, consts), rule_texts)
 --- modulename: gener, funcname: __init__
gener.py(558):         super(Rule, self).__init__()
gener.py(559):         pattern = re.compile(r'rule\s*\"(.*?)\"\s*(.*?)==>.*?begin(.*?)endrule\s*;', re.S)
gener.py(560):         self.name, guard, statements = pattern.findall(text)[0]
gener.py(561):         self.name = escape(self.name)
 --- modulename: gener, funcname: escape
gener.py(198):     return 'n_%s'%(re.sub(r'_+', '_', re.sub(r'[^a-zA-Z0-9]', '_', name).strip('_')))
gener.py(562):         self.params = params
gener.py(563):         self.param_names = param_names
gener.py(564):         self.formula = Formula(guard, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(212):         super(Formula, self).__init__()
gener.py(213):         self.param_names = param_names
gener.py(214):         self.consts = consts
gener.py(215):         try:
gener.py(216):             self.text = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(225):         dividers = r'(do|\sendforall|\sendexists|\send|\(|\)|=|!=|!|&|\||->)'
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
gener.py(227):         big_parts = []
gener.py(228):         to_add = []
gener.py(229):         exp_ends = 0
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(244):         if len(big_parts) == 0:
gener.py(248):         return big_parts
gener.py(217):             self.suffix = self.process(self.text)
 --- modulename: gener, funcname: process
gener.py(251):         ops = []
gener.py(252):         suffix = []
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(266):         return suffix
gener.py(218):             self.value = self.evaluate(self.suffix, self.param_names)
 --- modulename: gener, funcname: evaluate
gener.py(322):         values = []
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(350):         if values[0][0]: return values[0][1]
gener.py(565):         self.statement = Statement(statements, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(373):         super(Statement, self).__init__()
gener.py(374):         self.param_names = param_names
gener.py(375):         self.consts = consts
gener.py(376):         self.statements = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
gener.py(381):         big_parts = []
gener.py(382):         to_add = []
gener.py(383):         exp_ends = 0
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(398):         if len(big_parts) == 0:
gener.py(401):         return big_parts
gener.py(377):         self.value = self.evaluate(self.statements, self.param_names, self.consts)
 --- modulename: gener, funcname: evaluate
gener.py(509):         def inner(statement):
gener.py(528):         if len(statements) > 1:
gener.py(530):         elif len(statements) == 1:
gener.py(531):             return inner(statements[0])
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(415):                 'arr [(\"%s\", [%s])]' %(
gener.py(416):                     parts[0], 
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(425):             return '(const _%s)'%atom
gener.py(525):                     return '(assign %s %s)'%(v, e)
gener.py(571):   rule name params formula statement'''%(self.name, self.name, self.params, self.formula.value, self.statement.value)
 --- modulename: gener, funcname: <lambda>
gener.py(620):         rules = map(lambda r: Rule(r, [], {}, consts), rule_texts)
 --- modulename: gener, funcname: __init__
gener.py(558):         super(Rule, self).__init__()
gener.py(559):         pattern = re.compile(r'rule\s*\"(.*?)\"\s*(.*?)==>.*?begin(.*?)endrule\s*;', re.S)
gener.py(560):         self.name, guard, statements = pattern.findall(text)[0]
gener.py(561):         self.name = escape(self.name)
 --- modulename: gener, funcname: escape
gener.py(198):     return 'n_%s'%(re.sub(r'_+', '_', re.sub(r'[^a-zA-Z0-9]', '_', name).strip('_')))
gener.py(562):         self.params = params
gener.py(563):         self.param_names = param_names
gener.py(564):         self.formula = Formula(guard, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(212):         super(Formula, self).__init__()
gener.py(213):         self.param_names = param_names
gener.py(214):         self.consts = consts
gener.py(215):         try:
gener.py(216):             self.text = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(225):         dividers = r'(do|\sendforall|\sendexists|\send|\(|\)|=|!=|!|&|\||->)'
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
gener.py(227):         big_parts = []
gener.py(228):         to_add = []
gener.py(229):         exp_ends = 0
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(244):         if len(big_parts) == 0:
gener.py(248):         return big_parts
gener.py(217):             self.suffix = self.process(self.text)
 --- modulename: gener, funcname: process
gener.py(251):         ops = []
gener.py(252):         suffix = []
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(256):                     suffix.append(ops.pop())
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(266):         return suffix
gener.py(218):             self.value = self.evaluate(self.suffix, self.param_names)
 --- modulename: gener, funcname: evaluate
gener.py(322):         values = []
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(296):             return '(const (boolc %s))'%atom.lower()
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(330):             elif s == '!':
gener.py(337):             elif s in ['&', '|', '->']:
gener.py(338):                 def do_eval(evaled, atom):
gener.py(343):                 rval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(344):                 lval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(345):                 values.append((True, self.__RELATION_OP[s]%(lval, rval)))
gener.py(323):         for s in suffix:
gener.py(350):         if values[0][0]: return values[0][1]
gener.py(565):         self.statement = Statement(statements, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(373):         super(Statement, self).__init__()
gener.py(374):         self.param_names = param_names
gener.py(375):         self.consts = consts
gener.py(376):         self.statements = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
gener.py(381):         big_parts = []
gener.py(382):         to_add = []
gener.py(383):         exp_ends = 0
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(398):         if len(big_parts) == 0:
gener.py(401):         return big_parts
gener.py(377):         self.value = self.evaluate(self.statements, self.param_names, self.consts)
 --- modulename: gener, funcname: evaluate
gener.py(509):         def inner(statement):
gener.py(528):         if len(statements) > 1:
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: <lambda>
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(415):                 'arr [(\"%s\", [%s])]' %(
gener.py(416):                     parts[0], 
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(425):             return '(const _%s)'%atom
gener.py(525):                     return '(assign %s %s)'%(v, e)
 --- modulename: gener, funcname: <lambda>
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(426):         elif atom in param_names:
gener.py(428):         elif re.match(r'^\d+$', atom):
gener.py(430):         elif atom.lower() in ['true', 'false']:
gener.py(431):             return '(const (boolc %s))'%atom.lower()
gener.py(525):                     return '(assign %s %s)'%(v, e)
gener.py(571):   rule name params formula statement'''%(self.name, self.name, self.params, self.formula.value, self.statement.value)
 --- modulename: gener, funcname: <lambda>
gener.py(620):         rules = map(lambda r: Rule(r, [], {}, consts), rule_texts)
 --- modulename: gener, funcname: __init__
gener.py(558):         super(Rule, self).__init__()
gener.py(559):         pattern = re.compile(r'rule\s*\"(.*?)\"\s*(.*?)==>.*?begin(.*?)endrule\s*;', re.S)
gener.py(560):         self.name, guard, statements = pattern.findall(text)[0]
gener.py(561):         self.name = escape(self.name)
 --- modulename: gener, funcname: escape
gener.py(198):     return 'n_%s'%(re.sub(r'_+', '_', re.sub(r'[^a-zA-Z0-9]', '_', name).strip('_')))
gener.py(562):         self.params = params
gener.py(563):         self.param_names = param_names
gener.py(564):         self.formula = Formula(guard, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(212):         super(Formula, self).__init__()
gener.py(213):         self.param_names = param_names
gener.py(214):         self.consts = consts
gener.py(215):         try:
gener.py(216):             self.text = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(225):         dividers = r'(do|\sendforall|\sendexists|\send|\(|\)|=|!=|!|&|\||->)'
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
gener.py(227):         big_parts = []
gener.py(228):         to_add = []
gener.py(229):         exp_ends = 0
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(244):         if len(big_parts) == 0:
gener.py(248):         return big_parts
gener.py(217):             self.suffix = self.process(self.text)
 --- modulename: gener, funcname: process
gener.py(251):         ops = []
gener.py(252):         suffix = []
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(266):         return suffix
gener.py(218):             self.value = self.evaluate(self.suffix, self.param_names)
 --- modulename: gener, funcname: evaluate
gener.py(322):         values = []
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(350):         if values[0][0]: return values[0][1]
gener.py(565):         self.statement = Statement(statements, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(373):         super(Statement, self).__init__()
gener.py(374):         self.param_names = param_names
gener.py(375):         self.consts = consts
gener.py(376):         self.statements = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
gener.py(381):         big_parts = []
gener.py(382):         to_add = []
gener.py(383):         exp_ends = 0
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(398):         if len(big_parts) == 0:
gener.py(401):         return big_parts
gener.py(377):         self.value = self.evaluate(self.statements, self.param_names, self.consts)
 --- modulename: gener, funcname: evaluate
gener.py(509):         def inner(statement):
gener.py(528):         if len(statements) > 1:
gener.py(530):         elif len(statements) == 1:
gener.py(531):             return inner(statements[0])
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(415):                 'arr [(\"%s\", [%s])]' %(
gener.py(416):                     parts[0], 
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(425):             return '(const _%s)'%atom
gener.py(525):                     return '(assign %s %s)'%(v, e)
gener.py(571):   rule name params formula statement'''%(self.name, self.name, self.params, self.formula.value, self.statement.value)
 --- modulename: gener, funcname: <lambda>
gener.py(620):         rules = map(lambda r: Rule(r, [], {}, consts), rule_texts)
 --- modulename: gener, funcname: __init__
gener.py(558):         super(Rule, self).__init__()
gener.py(559):         pattern = re.compile(r'rule\s*\"(.*?)\"\s*(.*?)==>.*?begin(.*?)endrule\s*;', re.S)
gener.py(560):         self.name, guard, statements = pattern.findall(text)[0]
gener.py(561):         self.name = escape(self.name)
 --- modulename: gener, funcname: escape
gener.py(198):     return 'n_%s'%(re.sub(r'_+', '_', re.sub(r'[^a-zA-Z0-9]', '_', name).strip('_')))
gener.py(562):         self.params = params
gener.py(563):         self.param_names = param_names
gener.py(564):         self.formula = Formula(guard, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(212):         super(Formula, self).__init__()
gener.py(213):         self.param_names = param_names
gener.py(214):         self.consts = consts
gener.py(215):         try:
gener.py(216):             self.text = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(225):         dividers = r'(do|\sendforall|\sendexists|\send|\(|\)|=|!=|!|&|\||->)'
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
gener.py(227):         big_parts = []
gener.py(228):         to_add = []
gener.py(229):         exp_ends = 0
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(244):         if len(big_parts) == 0:
gener.py(248):         return big_parts
gener.py(217):             self.suffix = self.process(self.text)
 --- modulename: gener, funcname: process
gener.py(251):         ops = []
gener.py(252):         suffix = []
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(266):         return suffix
gener.py(218):             self.value = self.evaluate(self.suffix, self.param_names)
 --- modulename: gener, funcname: evaluate
gener.py(322):         values = []
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(350):         if values[0][0]: return values[0][1]
gener.py(565):         self.statement = Statement(statements, self.param_names, consts)
 --- modulename: gener, funcname: __init__
gener.py(373):         super(Statement, self).__init__()
gener.py(374):         self.param_names = param_names
gener.py(375):         self.consts = consts
gener.py(376):         self.statements = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
 --- modulename: gener, funcname: <lambda>
gener.py(380):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(r'(;|do|then|else)', text)))
gener.py(381):         big_parts = []
gener.py(382):         to_add = []
gener.py(383):         exp_ends = 0
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(397):                 big_parts.append(p)
gener.py(384):         for p in parts:
gener.py(385):             if p.startswith(('if', 'for')):
gener.py(388):             elif p.startswith('end'):
gener.py(394):             elif exp_ends > 0:
gener.py(396):             elif p != ';':
gener.py(384):         for p in parts:
gener.py(398):         if len(big_parts) == 0:
gener.py(401):         return big_parts
gener.py(377):         self.value = self.evaluate(self.statements, self.param_names, self.consts)
 --- modulename: gener, funcname: evaluate
gener.py(509):         def inner(statement):
gener.py(528):         if len(statements) > 1:
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: <lambda>
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(415):                 'arr [(\"%s\", [%s])]' %(
gener.py(416):                     parts[0], 
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(417):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(425):             return '(const _%s)'%atom
gener.py(525):                     return '(assign %s %s)'%(v, e)
 --- modulename: gener, funcname: <lambda>
gener.py(529):             return '(parallel [%s])'%('; '.join(map(lambda s: inner(s), statements)))
 --- modulename: gener, funcname: inner
gener.py(510):             if statement.startswith('if'):
gener.py(512):             elif statement.startswith('for'):
gener.py(514):             elif re.match(r'clear\s', statement):
gener.py(521):                 try:
gener.py(522):                     vstr, estr = statement.split(':=')
gener.py(523):                     v = self.evalVar(vstr.strip())
 --- modulename: gener, funcname: evalVar
gener.py(409):         name_parts = map(
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(411):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(410):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(413):         variables = map(
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(419):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(414):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(421):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(524):                     e = self.evalAtom(estr.strip(), param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(424):         if atom in self.consts:
gener.py(426):         elif atom in param_names:
gener.py(428):         elif re.match(r'^\d+$', atom):
gener.py(430):         elif atom.lower() in ['true', 'false']:
gener.py(431):             return '(const (boolc %s))'%atom.lower()
gener.py(525):                     return '(assign %s %s)'%(v, e)
gener.py(571):   rule name params formula statement'''%(self.name, self.name, self.params, self.formula.value, self.statement.value)
gener.py(621):         return filter(lambda r: r.name not in ruleset_names, rules)
 --- modulename: gener, funcname: <lambda>
gener.py(621):         return filter(lambda r: r.name not in ruleset_names, rules)
 --- modulename: gener, funcname: <lambda>
gener.py(621):         return filter(lambda r: r.name not in ruleset_names, rules)
 --- modulename: gener, funcname: <lambda>
gener.py(621):         return filter(lambda r: r.name not in ruleset_names, rules)
 --- modulename: gener, funcname: <lambda>
gener.py(621):         return filter(lambda r: r.name not in ruleset_names, rules)
gener.py(602):         self.value = '%s\n\nlet rules = [%s]'%(
gener.py(603):             '\n\n'.join(map(lambda r: r.value, rules)), 
 --- modulename: gener, funcname: <lambda>
gener.py(603):             '\n\n'.join(map(lambda r: r.value, rules)), 
 --- modulename: gener, funcname: <lambda>
gener.py(603):             '\n\n'.join(map(lambda r: r.value, rules)), 
 --- modulename: gener, funcname: <lambda>
gener.py(603):             '\n\n'.join(map(lambda r: r.value, rules)), 
 --- modulename: gener, funcname: <lambda>
gener.py(603):             '\n\n'.join(map(lambda r: r.value, rules)), 
gener.py(604):             '; '.join(map(lambda r: r.name, rules))
 --- modulename: gener, funcname: <lambda>
gener.py(604):             '; '.join(map(lambda r: r.name, rules))
 --- modulename: gener, funcname: <lambda>
gener.py(604):             '; '.join(map(lambda r: r.name, rules))
 --- modulename: gener, funcname: <lambda>
gener.py(604):             '; '.join(map(lambda r: r.name, rules))
 --- modulename: gener, funcname: <lambda>
gener.py(604):             '; '.join(map(lambda r: r.name, rules))
gener.py(737):         invs = Invariant(self.content, types.consts, types.typenames)
 --- modulename: gener, funcname: __init__
gener.py(668):         super(Invariant, self).__init__()
gener.py(669):         names = []
gener.py(670):         invs = []
gener.py(671):         invset_names, invset_invs = self.invsets(text, consts)
 --- modulename: gener, funcname: invsets
gener.py(680):         pattern = r'ruleset\s*([\w :;]*)do\s*invariant\s*\"(.*?)\"\s*(.*?)\s*;{0,1}\s*endruleset\s*;'
gener.py(681):         inv_strs = re.findall(pattern, text, re.S)
gener.py(682):         invs = []
gener.py(683):         names = []
gener.py(684):         for params, name, form in inv_strs:
gener.py(685):             param_name_dict, param_defs = analyzeParams(params)
 --- modulename: gener, funcname: analyzeParams
gener.py(183):     if not params:
gener.py(185):     parts = params.split(';')
gener.py(186):     param_name_dict = {}
gener.py(187):     for p in parts: param_name_dict[p.split(':')[0].strip()] = p.split(':')[1].strip()
gener.py(187):     for p in parts: param_name_dict[p.split(':')[0].strip()] = p.split(':')[1].strip()
gener.py(187):     for p in parts: param_name_dict[p.split(':')[0].strip()] = p.split(':')[1].strip()
gener.py(188):     param_defs = map(
gener.py(189):         lambda x: 'paramdef ' + ' '.join(map(
gener.py(193):         parts
 --- modulename: gener, funcname: <lambda>
gener.py(189):         lambda x: 'paramdef ' + ' '.join(map(
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
gener.py(191):             x.strip().split(':'))
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
 --- modulename: gener, funcname: <lambda>
gener.py(189):         lambda x: 'paramdef ' + ' '.join(map(
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
gener.py(191):             x.strip().split(':'))
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
 --- modulename: gener, funcname: <lambda>
gener.py(190):             lambda y: '\"%s\"'%y.strip(), 
gener.py(195):     return param_name_dict, '[%s]'%('; '.join(param_defs))
gener.py(686):             name = escape(name)
 --- modulename: gener, funcname: escape
gener.py(198):     return 'n_%s'%(re.sub(r'_+', '_', re.sub(r'[^a-zA-Z0-9]', '_', name).strip('_')))
gener.py(687):             formula = Formula(form, param_name_dict, consts)
 --- modulename: gener, funcname: __init__
gener.py(212):         super(Formula, self).__init__()
gener.py(213):         self.param_names = param_names
gener.py(214):         self.consts = consts
gener.py(215):         try:
gener.py(216):             self.text = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(225):         dividers = r'(do|\sendforall|\sendexists|\send|\(|\)|=|!=|!|&|\||->)'
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
gener.py(227):         big_parts = []
gener.py(228):         to_add = []
gener.py(229):         exp_ends = 0
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(244):         if len(big_parts) == 0:
gener.py(248):         return big_parts
gener.py(217):             self.suffix = self.process(self.text)
 --- modulename: gener, funcname: process
gener.py(251):         ops = []
gener.py(252):         suffix = []
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(256):                     suffix.append(ops.pop())
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(256):                     suffix.append(ops.pop())
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(259):                 while ops[-1] != '(':
gener.py(260):                     suffix.append(ops.pop())
gener.py(259):                 while ops[-1] != '(':
gener.py(260):                     suffix.append(ops.pop())
gener.py(259):                 while ops[-1] != '(':
gener.py(261):                 ops.pop()
gener.py(253):         for t in text:
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(266):         return suffix
gener.py(218):             self.value = self.evaluate(self.suffix, self.param_names)
 --- modulename: gener, funcname: evaluate
gener.py(322):         values = []
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(292):             return '(param (paramref \"%s\"))'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(292):             return '(param (paramref \"%s\"))'%atom
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(330):             elif s == '!':
gener.py(337):             elif s in ['&', '|', '->']:
gener.py(338):                 def do_eval(evaled, atom):
gener.py(343):                 rval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(344):                 lval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(345):                 values.append((True, self.__RELATION_OP[s]%(lval, rval)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(330):             elif s == '!':
gener.py(337):             elif s in ['&', '|', '->']:
gener.py(338):                 def do_eval(evaled, atom):
gener.py(343):                 rval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(344):                 lval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(345):                 values.append((True, self.__RELATION_OP[s]%(lval, rval)))
gener.py(323):         for s in suffix:
gener.py(350):         if values[0][0]: return values[0][1]
gener.py(688):             names.append(name)
gener.py(689):             invs.append('''let %s =
gener.py(693):   prop name params formula'''%(name, name, param_defs, formula.value))
gener.py(684):         for params, name, form in inv_strs:
gener.py(694):         return names, invs
gener.py(672):         names += invset_names
gener.py(673):         invs += invset_invs
gener.py(674):         inv_alone_names, inv_alone_invs = self.inv_alone(text, consts)
 --- modulename: gener, funcname: inv_alone
gener.py(698):         pattern = r'[^do]+\s+invariant\s*?\"(.*?)\"\s*?(.*?)\s*?;'
gener.py(699):         inv_strs = re.findall(pattern, text, re.S)
gener.py(700):         invs = []
gener.py(701):         names = []
gener.py(702):         for name, form in inv_strs:
gener.py(703):             print name, form
coherence 
  i != j -> (n[i] = C -> n[j] != C)
gener.py(704):             name = escape(name)
 --- modulename: gener, funcname: escape
gener.py(198):     return 'n_%s'%(re.sub(r'_+', '_', re.sub(r'[^a-zA-Z0-9]', '_', name).strip('_')))
gener.py(705):             formula = Formula(form, [], consts)
 --- modulename: gener, funcname: __init__
gener.py(212):         super(Formula, self).__init__()
gener.py(213):         self.param_names = param_names
gener.py(214):         self.consts = consts
gener.py(215):         try:
gener.py(216):             self.text = self.splitText(text)
 --- modulename: gener, funcname: splitText
gener.py(225):         dividers = r'(do|\sendforall|\sendexists|\send|\(|\)|=|!=|!|&|\||->)'
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
 --- modulename: gener, funcname: <lambda>
gener.py(226):         parts = filter(lambda p: p, map(lambda x: x.strip(), re.split(dividers, text)))
gener.py(227):         big_parts = []
gener.py(228):         to_add = []
gener.py(229):         exp_ends = 0
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(231):             if p.startswith(('forall', 'exists')):
gener.py(234):             elif p.startswith('end'):
gener.py(240):             elif exp_ends > 0:
gener.py(243):                 big_parts.append(p)
gener.py(230):         for p in parts:
gener.py(244):         if len(big_parts) == 0:
gener.py(248):         return big_parts
gener.py(217):             self.suffix = self.process(self.text)
 --- modulename: gener, funcname: process
gener.py(251):         ops = []
gener.py(252):         suffix = []
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(256):                     suffix.append(ops.pop())
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(256):                     suffix.append(ops.pop())
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(255):                 while ops != [] and ops[-1] != '(' and self.__PRIORITY[t] <= self.__PRIORITY[ops[-1]]:
gener.py(257):                 ops.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(263):                 suffix.append(t)
gener.py(253):         for t in text:
gener.py(254):             if t in self.__PRIORITY:
gener.py(258):             elif t == ')':
gener.py(259):                 while ops[-1] != '(':
gener.py(260):                     suffix.append(ops.pop())
gener.py(259):                 while ops[-1] != '(':
gener.py(260):                     suffix.append(ops.pop())
gener.py(259):                 while ops[-1] != '(':
gener.py(261):                 ops.pop()
gener.py(253):         for t in text:
gener.py(264):         while ops != []:
gener.py(265):             suffix.append(ops.pop())
gener.py(264):         while ops != []:
gener.py(266):         return suffix
gener.py(218):             self.value = self.evaluate(self.suffix, self.param_names)
 --- modulename: gener, funcname: evaluate
gener.py(322):         values = []
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(325):                 values.append((False, s))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(327):                 right = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(290):             return '(const _%s)'%atom
gener.py(328):                 left = self.evalAtom(values.pop()[1], param_names)
 --- modulename: gener, funcname: evalAtom
gener.py(289):         if atom in self.consts:
gener.py(291):         elif atom in param_names:
gener.py(293):         elif re.match(r'^\d+$', atom):
gener.py(295):         elif atom.lower() in ['true', 'false']:
gener.py(297):         elif re.match(r'^forall.*end$', atom) or re.match(r'^exists.*?end$', atom):
gener.py(312):             return '(var %s)'%self.evalVar(atom)
 --- modulename: gener, funcname: evalVar
gener.py(274):         name_parts = map(
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(276):             var.split('.')
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
 --- modulename: gener, funcname: <lambda>
gener.py(275):             lambda n: map(lambda x: x.strip(']'), n.split('[')), 
gener.py(278):         variables = map(
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(284):             name_parts
 --- modulename: gener, funcname: <lambda>
gener.py(279):             lambda parts: 'global \"%s\"'%parts[0] if len(parts) == 1 else\
gener.py(280):                 'arr [(\"%s\", [%s])]' %(
gener.py(281):                     parts[0], 
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
 --- modulename: gener, funcname: <lambda>
gener.py(282):                     '; '.join(map(lambda p: 'paramref \"%s\"'%p, parts[1:]))
gener.py(286):         return '(%s)'%variables[0] if len(variables) == 1 else '(record [%s])'%('; '.join(variables))
gener.py(329):                 values.append((True, self.__RELATION_OP[s]%(left, right)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(330):             elif s == '!':
gener.py(337):             elif s in ['&', '|', '->']:
gener.py(338):                 def do_eval(evaled, atom):
gener.py(343):                 rval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(344):                 lval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(345):                 values.append((True, self.__RELATION_OP[s]%(lval, rval)))
gener.py(323):         for s in suffix:
gener.py(324):             if s not in self.__PRIORITY:
gener.py(326):             elif s in ['=', '!=']:
gener.py(330):             elif s == '!':
gener.py(337):             elif s in ['&', '|', '->']:
gener.py(338):                 def do_eval(evaled, atom):
gener.py(343):                 rval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(344):                 lval = do_eval(*values.pop())
 --- modulename: gener, funcname: do_eval
gener.py(339):                     if evaled: return atom
gener.py(345):                 values.append((True, self.__RELATION_OP[s]%(lval, rval)))
gener.py(323):         for s in suffix:
gener.py(350):         if values[0][0]: return values[0][1]
gener.py(706):             names.append(name)
gener.py(707):             invs.append('''let %s =
gener.py(711):   prop name params formula'''%(name, name, formula.value))
gener.py(702):         for name, form in inv_strs:
gener.py(712):         return names, invs
gener.py(675):         names += inv_alone_names
gener.py(676):         invs += inv_alone_invs
gener.py(677):         self.value = '%s\n\nlet properties = [%s]'%('\n\n'.join(invs), '; '.join(names))
gener.py(761): )\n'''%(
gener.py(762):     types.value, records.value, vardefs.value, init.value, 
gener.py(763):     rulesets.value, invs.value, self.name, self.name)
gener.py(769):     print protocol.value

(* This program is translated from its corresponding murphi version *)

open Core.Std
open Utils
open Paramecium
open Loach
open Formula
open InvFinder
open Cmdline

let _I = strc "I"
let _T = strc "T"
let _C = strc "C"
let _E = strc "E"
let _True = boolc true
let _False = boolc false

let types = [
  enum "state" [_I; _T; _C; _E];
  enum "client" (int_consts [1; 2]);
  enum "boolean" [_True; _False];
]



let vardefs = List.concat [
  [arrdef [("n", [paramdef "i0" "client"])] "state"];
  [arrdef [("x", [])] "boolean"]
]

let init = (parallel [(forStatement (assign (arr [("n", [paramref "i"])]) (const _I)) [paramdef "i" "client"]); (assign (global "x") (const (boolc true)))])

let n_Try =
  let name = "n_Try" in
  let params = [paramdef "i" "client"] in
  let formula = (eqn (var (arr [("n", [paramref "i"])])) (const _I)) in
  let statement = (assign (arr [("n", [paramref "i"])]) (const _T)) in
  rule name params formula statement

let n_Crit =
  let name = "n_Crit" in
  let params = [paramdef "i" "client"] in
  let formula = (andList [(eqn (var (arr [("n", [paramref "i"])])) (const _T)); (eqn (var (global "x")) (const (boolc true)))]) in
  let statement = (parallel [(assign (arr [("n", [paramref "i"])]) (const _C)); (assign (global "x") (const (boolc false)))]) in
  rule name params formula statement

let n_Exit =
  let name = "n_Exit" in
  let params = [paramdef "i" "client"] in
  let formula = (eqn (var (arr [("n", [paramref "i"])])) (const _C)) in
  let statement = (assign (arr [("n", [paramref "i"])]) (const _E)) in
  rule name params formula statement

let n_Idle =
  let name = "n_Idle" in
  let params = [paramdef "i" "client"] in
  let formula = (eqn (var (arr [("n", [paramref "i"])])) (const _E)) in
  let statement = (parallel [(assign (arr [("n", [paramref "i"])]) (const _I)); (assign (global "x") (const (boolc true)))]) in
  rule name params formula statement

let rules = [n_Try; n_Crit; n_Exit; n_Idle]

let n_coherence =
  let name = "n_coherence" in
  let params = [paramdef "i" "client"; paramdef "j" "client"] in
  let formula = (imply (neg (eqn (param (paramref "i")) (param (paramref "j")))) (imply (eqn (var (arr [("n", [paramref "i"])])) (const _C)) (neg (eqn (var (arr [("n", [paramref "j"])])) (const _C))))) in
  prop name params formula

let n_coherence =
  let name = "n_coherence" in
  let params = [] in
  let formula = (imply (neg (eqn (var (global "i")) (var (global "j")))) (imply (eqn (var (arr [("n", [paramref "i"])])) (const _C)) (neg (eqn (var (arr [("n", [paramref "j"])])) (const _C))))) in
  prop name params formula

let properties = [n_coherence; n_coherence]


let protocol = {
  name = "n_mutualEx";
  types;
  vardefs;
  init;
  rules;
  properties;
}

let () = run_with_cmdline (fun () ->
  let protocol = preprocess_rule_guard ~loach:protocol in
  let cinvs_with_varnames, relations = find protocol
    ~murphi:(In_channel.read_all "n_mutualEx.m")
  in
  Isabelle.protocol_act protocol cinvs_with_varnames relations ()
)

