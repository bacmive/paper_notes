!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AIGDIR	makefile	/^AIGDIR = $(SRCDIR)\/aiglib$/;"	m
AIGER_VERSION	aiger/aiger.h	37;"	d
And	simpleIC3/aiglib/aiglib.h	/^	Literal And(Literal a)$/;"	f	class:aiglib::Circuit
And	simpleIC3/aiglib/aiglib.h	/^	Literal And(Literal a, Literal b){$/;"	f	class:aiglib::Circuit
And	simpleIC3/aiglib/aiglib.h	/^	Literal And(Literal a, Literal b, Args... args)$/;"	f	class:aiglib::Circuit
And	simpleIC3/aiglib/aiglib.h	/^	Literal And(const std::list<Literal> & vals){$/;"	f	class:aiglib::Circuit
And	simpleIC3/aiglib/aiglib.h	/^	Literal And(const std::vector<Literal> & vals){$/;"	f	class:aiglib::Circuit
And	simpleIC3/util/Bitset.h	/^    void And(const Bitset & with){$/;"	f	class:SimpIC3::Bitset
And	simpleIC3/util/Bitset.h	/^    void And(const Bitset & with, Bitset & out){$/;"	f	class:SimpIC3::Bitset
BIN_TARGET	makefile	/^BIN_TARGET=${TOPDIR}\/${TARGET}$/;"	m
BITSET_ELEMENT_SIZE	simpleIC3/util/Bitset.h	33;"	d
BITSET_H_	simpleIC3/util/Bitset.h	24;"	d
BUILD_DIR	minisat/Makefile	/^BUILD_DIR      ?= build$/;"	m
Bitset	simpleIC3/util/Bitset.h	/^    Bitset():sz(0)  {}$/;"	f	class:SimpIC3::Bitset
Bitset	simpleIC3/util/Bitset.h	/^    Bitset(int size):sz(size)  {buf.growTo(size\/BITSET_ELEMENT_SIZE + 1);}$/;"	f	class:SimpIC3::Bitset
Bitset	simpleIC3/util/Bitset.h	/^    Bitset(int size, bool default_value):sz(size)  {$/;"	f	class:SimpIC3::Bitset
Bitset	simpleIC3/util/Bitset.h	/^class Bitset {$/;"	c	namespace:SimpIC3
BoolOption	minisat/minisat/utils/Options.h	/^    BoolOption(const char* c, const char* n, const char* d, bool v) $/;"	f	class:Minisat::BoolOption
BoolOption	minisat/minisat/utils/Options.h	/^class BoolOption : public Option$/;"	c	namespace:Minisat
CC	makefile	/^CC = g++$/;"	m
CFLAGS	makefile	/^CFLAGS = -std=c++11 -g -Wall$/;"	m
CLR	aiger/aiger.c	108;"	d	file:
CMap	minisat/minisat/core/SolverTypes.h	/^class CMap$/;"	c	namespace:Minisat
CONE_H_	simpleIC3/ic3/Cone.h	25;"	d
CRef	minisat/minisat/core/SolverTypes.h	/^typedef RegionAllocator<uint32_t>::Ref CRef;$/;"	t	namespace:Minisat
CRefHash	minisat/minisat/core/SolverTypes.h	/^    struct CRefHash {$/;"	s	class:Minisat::CMap
CRef_Undef	minisat/minisat/core/SolverTypes.h	/^const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;$/;"	m	namespace:Minisat
Circuit	simpleIC3/aiglib/aiglib.h	/^	Circuit(){$/;"	f	class:aiglib::Circuit
Circuit	simpleIC3/aiglib/aiglib.h	/^class Circuit{$/;"	c	namespace:aiglib
Clause	minisat/minisat/core/SolverTypes.h	/^    Clause(const Clause& from, bool use_extra){$/;"	f	class:Minisat::Clause
Clause	minisat/minisat/core/SolverTypes.h	/^    Clause(const vec<Lit>& ps, bool use_extra, bool learnt) {$/;"	f	class:Minisat::Clause
Clause	minisat/minisat/core/SolverTypes.h	/^class Clause {$/;"	c	namespace:Minisat
ClauseAllocator	minisat/minisat/core/SolverTypes.h	/^    ClauseAllocator() : extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator
ClauseAllocator	minisat/minisat/core/SolverTypes.h	/^    ClauseAllocator(uint32_t start_cap) : ra(start_cap), extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator
ClauseAllocator	minisat/minisat/core/SolverTypes.h	/^class ClauseAllocator$/;"	c	namespace:Minisat
ClauseDeleted	minisat/minisat/simp/SimpSolver.h	/^        explicit ClauseDeleted(const ClauseAllocator& _ca) : ca(_ca) {}$/;"	f	struct:Minisat::SimpSolver::ClauseDeleted
ClauseDeleted	minisat/minisat/simp/SimpSolver.h	/^    struct ClauseDeleted {$/;"	s	class:Minisat::SimpSolver
ClauseIterator	minisat/minisat/core/SolverTypes.h	/^    ClauseIterator(const ClauseAllocator& _ca, const CRef* _crefs) : ca(_ca), crefs(_crefs){}$/;"	f	class:Minisat::ClauseIterator
ClauseIterator	minisat/minisat/core/SolverTypes.h	/^class ClauseIterator {$/;"	c	namespace:Minisat
ConeOfInfluence	simpleIC3/ic3/Cone.h	/^	ConeOfInfluence(aiger * _mgr):mgr(_mgr){$/;"	f	class:SimpIC3::ConeOfInfluence
ConeOfInfluence	simpleIC3/ic3/Cone.h	/^class ConeOfInfluence{$/;"	c	namespace:SimpIC3
DELETE	aiger/aiger.c	111;"	d	file:
DELETEN	aiger/aiger.c	101;"	d	file:
DeepEqual	minisat/minisat/mtl/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	s	namespace:Minisat
DeepHash	minisat/minisat/mtl/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	s	namespace:Minisat
DoubleOption	minisat/minisat/utils/Options.h	/^    DoubleOption(const char* c, const char* n, const char* d, double def = double(), DoubleRange r = DoubleRange(-HUGE_VAL, false, HUGE_VAL, false))$/;"	f	class:Minisat::DoubleOption
DoubleOption	minisat/minisat/utils/Options.h	/^class DoubleOption : public Option$/;"	c	namespace:Minisat
DoubleRange	minisat/minisat/utils/Options.h	/^    DoubleRange(double b, bool binc, double e, bool einc) : begin(b), end(e), begin_inclusive(binc), end_inclusive(einc) {}$/;"	f	struct:Minisat::DoubleRange
DoubleRange	minisat/minisat/utils/Options.h	/^struct DoubleRange {$/;"	s	namespace:Minisat
ECHO	minisat/Makefile	/^ECHO=@echo$/;"	m
ENLARGE	aiger/aiger.c	86;"	d	file:
EXPORT_public_FROM	aiger/aiger.c	116;"	d	file:
ElimLt	minisat/minisat/simp/SimpSolver.h	/^        explicit ElimLt(const LMap<int>& no) : n_occ(no) {}$/;"	f	struct:Minisat::SimpSolver::ElimLt
ElimLt	minisat/minisat/simp/SimpSolver.h	/^    struct ElimLt {$/;"	s	class:Minisat::SimpSolver
Equal	minisat/minisat/mtl/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	s	namespace:Minisat
Equiv	simpleIC3/util/Bitset.h	/^    bool Equiv(const Bitset & with){$/;"	f	class:SimpIC3::Bitset
FIT	aiger/aiger.c	75;"	d	file:
False	simpleIC3/aiglib/aiglib.h	/^	False,True,Undef$/;"	m	class:aiglib::Value
False	simpleIC3/aiglib/aiglib.h	/^const Literal False =  Literal(aiger_false);$/;"	m	namespace:aiglib
GUNZIP	aiger/aiger.c	53;"	d	file:
GZIP	aiger/aiger.c	52;"	d	file:
GreaterThan	simpleIC3/util/Bitset.h	/^    bool GreaterThan(const Bitset & with){$/;"	f	class:SimpIC3::Bitset
HDRS	minisat/Makefile	/^HDRS = $(wildcard minisat\/mtl\/*.h) $(wildcard minisat\/core\/*.h) $(wildcard minisat\/simp\/*.h) $(wildcard minisat\/utils\/*.h)$/;"	m
Hash	minisat/minisat/mtl/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	s	namespace:Minisat
HashTable	minisat/minisat/core/SolverTypes.h	/^    typedef Map<CRef, T, CRefHash> HashTable;$/;"	t	class:Minisat::CMap
Heap	minisat/minisat/mtl/Heap.h	/^    Heap(const Comp& c, MkIndex _index = MkIndex()) : indices(_index), lt(c) {}$/;"	f	class:Minisat::Heap
Heap	minisat/minisat/mtl/Heap.h	/^class Heap {$/;"	c	namespace:Minisat
IC3	simpleIC3/ic3/ic3.h	/^	IC3(SimpSolver & S,aiger * mgr, vec<Var> & in_latches, vec<Var> & out_latches, vec<lbool> & resets,vec<Var> & primary_inputs ):S(S),mgr(mgr),in_latches(in_latches),out_latches(out_latches),resets(resets),primary_inputs(primary_inputs){$/;"	f	class:SimpIC3::IC3
IC3	simpleIC3/ic3/ic3.h	/^class IC3{$/;"	c	namespace:SimpIC3
IC3CONFIG_H_	simpleIC3/ic3/ic3config.h	22;"	d
IC3DIR	makefile	/^IC3DIR = $(SRCDIR)\/ic3$/;"	m
IC3TYPES_H_	simpleIC3/ic3/ic3Types.h	23;"	d
IC3_H_	simpleIC3/ic3/ic3.h	22;"	d
IMPORT_private_FROM	aiger/aiger.c	113;"	d	file:
INCLUDE	makefile	/^INCLUDE =-I minisat -I minisat\/minisat\/core -I minisat\/minisat\/mtl -I minisat\/minisat\/simp -I aiger -I simpleIC3 -I simpleIC3\/aiglib -I simpleIC3\/util$/;"	m
INSTALL	minisat/Makefile	/^INSTALL ?= install$/;"	m
Int64Option	minisat/minisat/utils/Options.h	/^    Int64Option(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))$/;"	f	class:Minisat::Int64Option
Int64Option	minisat/minisat/utils/Options.h	/^class Int64Option : public Option$/;"	c	namespace:Minisat
Int64Range	minisat/minisat/utils/Options.h	/^    Int64Range(int64_t b, int64_t e) : begin(b), end(e) {}$/;"	f	struct:Minisat::Int64Range
Int64Range	minisat/minisat/utils/Options.h	/^struct Int64Range {$/;"	s	namespace:Minisat
IntCmp	simpleIC3/util/VHeap.h	/^    	 IntCmp(){};$/;"	f	struct:SimpIC3::VHeap::IntCmp
IntCmp	simpleIC3/util/VHeap.h	/^    struct IntCmp{$/;"	s	class:SimpIC3::VHeap
IntMap	minisat/minisat/mtl/IntMap.h	/^        explicit IntMap(MkIndex _index = MkIndex()) : index(_index){}$/;"	f	class:Minisat::IntMap
IntMap	minisat/minisat/mtl/IntMap.h	/^    class IntMap {$/;"	c	namespace:Minisat
IntOption	minisat/minisat/utils/Options.h	/^    IntOption(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))$/;"	f	class:Minisat::IntOption
IntOption	minisat/minisat/utils/Options.h	/^class IntOption : public Option$/;"	c	namespace:Minisat
IntRange	minisat/minisat/utils/Options.h	/^    IntRange(int b, int e) : begin(b), end(e) {}$/;"	f	struct:Minisat::IntRange
IntRange	minisat/minisat/utils/Options.h	/^struct IntRange {$/;"	s	namespace:Minisat
IntSet	minisat/minisat/mtl/IntMap.h	/^    class IntSet$/;"	c	namespace:Minisat
Ite	simpleIC3/aiglib/Word.h	/^inline Word Ite(Literal cond, Word    thn, Word   els){$/;"	f
Ite	simpleIC3/aiglib/aiglib.h	/^	Literal Ite(Literal cond, Literal thn, Literal els=False){$/;"	f	class:aiglib::Circuit
Key	minisat/minisat/mtl/Queue.h	/^    typedef T Key;$/;"	t	class:Minisat::Queue
LDFLAGS	makefile	/^LDFLAGS = -lz$/;"	m
LMap	minisat/minisat/core/SolverTypes.h	/^template<class T> class LMap : public IntMap<Lit, T, MkIndexLit>{};$/;"	c	namespace:Minisat
LSet	minisat/minisat/core/SolverTypes.h	/^class LSet : public IntSet<Lit, MkIndexLit>{};$/;"	c	namespace:Minisat
LessThanClause	simpleIC3/ic3/ic3.h	/^		LessThanClause(IC3 * outer):outer(outer){	}$/;"	f	struct:SimpIC3::IC3::LessThanClause
LessThanClause	simpleIC3/ic3/ic3.h	/^	struct LessThanClause{$/;"	s	class:SimpIC3::IC3
LessThan_default	minisat/minisat/mtl/Sort.h	/^struct LessThan_default {$/;"	s	namespace:Minisat
Lit	minisat/minisat/core/SolverTypes.h	/^struct Lit {$/;"	s	namespace:Minisat
Literal	simpleIC3/aiglib/aiglib.h	/^	Literal():x(aiger_true){$/;"	f	struct:aiglib::Literal
Literal	simpleIC3/aiglib/aiglib.h	/^	explicit Literal(int x):x(x){$/;"	f	struct:aiglib::Literal
Literal	simpleIC3/aiglib/aiglib.h	/^struct Literal{$/;"	s	namespace:aiglib
MINISAT	minisat/Makefile	/^MINISAT      = minisat#       Name of MiniSat main executable.$/;"	m
MINISAT_CORE	minisat/Makefile	/^MINISAT_CORE = minisat_core#  Name of simplified MiniSat executable (only core solver support).$/;"	m
MINISAT_CXXFLAGS	minisat/Makefile	/^MINISAT_CXXFLAGS = -I. -D __STDC_LIMIT_MACROS -D __STDC_FORMAT_MACROS -Wall -Wno-parentheses -Wextra$/;"	m
MINISAT_DEB	minisat/Makefile	/^MINISAT_DEB    ?= -O0 -D DEBUG $/;"	m
MINISAT_DLIB	minisat/Makefile	/^MINISAT_DLIB = lib$(MINISAT).so# Name of MiniSat shared library.$/;"	m
MINISAT_FPIC	minisat/Makefile	/^MINISAT_FPIC   ?= -fpic$/;"	m
MINISAT_LDFLAGS	minisat/Makefile	/^MINISAT_LDFLAGS  = -Wall -lz$/;"	m
MINISAT_PRF	minisat/Makefile	/^MINISAT_PRF    ?= -O3 -D NDEBUG$/;"	m
MINISAT_REL	minisat/Makefile	/^MINISAT_REL    ?= -O3 -D NDEBUG$/;"	m
MINISAT_RELSYM	minisat/Makefile	/^MINISAT_RELSYM ?= -g$/;"	m
MINISAT_SLIB	minisat/Makefile	/^MINISAT_SLIB = lib$(MINISAT).a#  Name of MiniSat static library.$/;"	m
Map	minisat/minisat/mtl/Map.h	/^    Map () : table(NULL), cap(0), size(0) {}$/;"	f	class:Minisat::Map
Map	minisat/minisat/mtl/Map.h	/^    Map (const H& h, const E& e) : hash(h), equals(e), table(NULL), cap(0), size(0){}$/;"	f	class:Minisat::Map
Map	minisat/minisat/mtl/Map.h	/^class Map {$/;"	c	namespace:Minisat
Minisat	minisat/minisat/core/Dimacs.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/core/Solver.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/core/SolverTypes.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/mtl/Alg.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/mtl/Alloc.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/mtl/Heap.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/mtl/IntMap.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/mtl/Map.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/mtl/Queue.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/mtl/Rnd.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/mtl/Sort.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/mtl/Vec.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/mtl/XAlloc.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/simp/SimpSolver.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/utils/Options.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/utils/ParseUtils.h	/^namespace Minisat {$/;"	n
Minisat	minisat/minisat/utils/System.h	/^namespace Minisat {$/;"	n
Minisat_Alg_h	minisat/minisat/mtl/Alg.h	22;"	d
Minisat_Alloc_h	minisat/minisat/mtl/Alloc.h	22;"	d
Minisat_Dimacs_h	minisat/minisat/core/Dimacs.h	22;"	d
Minisat_Heap_h	minisat/minisat/mtl/Heap.h	22;"	d
Minisat_IntMap_h	minisat/minisat/mtl/IntMap.h	20;"	d
Minisat_IntTypes_h	minisat/minisat/mtl/IntTypes.h	21;"	d
Minisat_Map_h	minisat/minisat/mtl/Map.h	21;"	d
Minisat_Options_h	minisat/minisat/utils/Options.h	21;"	d
Minisat_ParseUtils_h	minisat/minisat/utils/ParseUtils.h	22;"	d
Minisat_Queue_h	minisat/minisat/mtl/Queue.h	22;"	d
Minisat_Rnd_h	minisat/minisat/mtl/Rnd.h	20;"	d
Minisat_SimpSolver_h	minisat/minisat/simp/SimpSolver.h	22;"	d
Minisat_SolverTypes_h	minisat/minisat/core/SolverTypes.h	23;"	d
Minisat_Solver_h	minisat/minisat/core/Solver.h	22;"	d
Minisat_Sort_h	minisat/minisat/mtl/Sort.h	22;"	d
Minisat_System_h	minisat/minisat/utils/System.h	22;"	d
Minisat_Vec_h	minisat/minisat/mtl/Vec.h	22;"	d
Minisat_XAlloc_h	minisat/minisat/mtl/XAlloc.h	22;"	d
MkIndexDefault	minisat/minisat/mtl/IntMap.h	/^    template<class T> struct MkIndexDefault {$/;"	s	namespace:Minisat
MkIndexLit	minisat/minisat/core/SolverTypes.h	/^struct MkIndexLit { vec<Lit>::Size operator()(Lit l) const { return vec<Lit>::Size(l.x); } };$/;"	s	namespace:Minisat
NEW	aiger/aiger.c	110;"	d	file:
NEWN	aiger/aiger.c	55;"	d	file:
Nand	simpleIC3/aiglib/aiglib.h	/^	Literal Nand(Literal a)$/;"	f	class:aiglib::Circuit
Nand	simpleIC3/aiglib/aiglib.h	/^	Literal Nand(Literal a, Literal b){$/;"	f	class:aiglib::Circuit
Nand	simpleIC3/aiglib/aiglib.h	/^	Literal Nand(Literal a, Literal b, Args... args)$/;"	f	class:aiglib::Circuit
Nand	simpleIC3/aiglib/aiglib.h	/^	Literal Nand(const std::list<Literal> & vals){$/;"	f	class:aiglib::Circuit
Nand	simpleIC3/aiglib/aiglib.h	/^	Literal Nand(const std::vector<Literal> & vals){$/;"	f	class:aiglib::Circuit
Nor	simpleIC3/aiglib/aiglib.h	/^	Literal Nor(Literal a)$/;"	f	class:aiglib::Circuit
Nor	simpleIC3/aiglib/aiglib.h	/^	Literal Nor(Literal a, Literal b){$/;"	f	class:aiglib::Circuit
Nor	simpleIC3/aiglib/aiglib.h	/^	Literal Nor(Literal a, Literal b, Args... args)	{$/;"	f	class:aiglib::Circuit
Nor	simpleIC3/aiglib/aiglib.h	/^	Literal Nor(const std::list<Literal> & vals){$/;"	f	class:aiglib::Circuit
Nor	simpleIC3/aiglib/aiglib.h	/^	Literal Nor(const std::vector<Literal> & vals){$/;"	f	class:aiglib::Circuit
Not	simpleIC3/util/Bitset.h	/^    void Not(Bitset & out){$/;"	f	class:SimpIC3::Bitset
NotSelf	simpleIC3/util/Bitset.h	/^    void NotSelf(){ \/\/ "Not", save result in this bitset.$/;"	f	class:SimpIC3::Bitset
OBJ	makefile	/^OBJ=${patsubst %.cpp, $(IC3DIR)\/%.o, ${notdir ${SRC}}}$/;"	m
OBJS	minisat/Makefile	/^OBJS = $(filter-out %Main.o, $(SRCS:.cc=.o))$/;"	m
OccLists	minisat/minisat/core/SolverTypes.h	/^    OccLists(const Deleted& d, MkIndex _index = MkIndex()) :$/;"	f	class:Minisat::OccLists
OccLists	minisat/minisat/core/SolverTypes.h	/^class OccLists$/;"	c	namespace:Minisat
Option	minisat/minisat/utils/Options.h	/^    Option(const char* name_, $/;"	f	class:Minisat::Option
Option	minisat/minisat/utils/Options.h	/^class Option$/;"	c	namespace:Minisat
OptionLt	minisat/minisat/utils/Options.h	/^    struct OptionLt {$/;"	s	class:Minisat::Option
Or	simpleIC3/aiglib/aiglib.h	/^	Literal Or(Literal a)$/;"	f	class:aiglib::Circuit
Or	simpleIC3/aiglib/aiglib.h	/^	Literal Or(Literal a, Literal b){$/;"	f	class:aiglib::Circuit
Or	simpleIC3/aiglib/aiglib.h	/^	Literal Or(Literal a, Literal b, Args... args)$/;"	f	class:aiglib::Circuit
Or	simpleIC3/aiglib/aiglib.h	/^	Literal Or(const std::list<Literal> & vals){$/;"	f	class:aiglib::Circuit
Or	simpleIC3/aiglib/aiglib.h	/^	Literal Or(const std::vector<Literal> & vals){$/;"	f	class:aiglib::Circuit
Or	simpleIC3/util/Bitset.h	/^    void Or(const Bitset & with){$/;"	f	class:SimpIC3::Bitset
Or	simpleIC3/util/Bitset.h	/^    void Or(const Bitset & with, Bitset & out){$/;"	f	class:SimpIC3::Bitset
OutOfMemoryException	minisat/minisat/mtl/XAlloc.h	/^class OutOfMemoryException{};$/;"	c	namespace:Minisat
PARSE_AIG	simpleIC3/aiglib/aigtocnf.h	22;"	d
PUSH	aiger/aiger.c	94;"	d	file:
Pair	minisat/minisat/mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	s	class:Minisat::Map
Q	simpleIC3/ic3/ic3.h	/^	VHeap<TCube*> Q;\/\/Q of bad states to process$/;"	m	class:SimpIC3::IC3
Q	simpleIC3/util/VHeap.h	/^    Heap<int,IntCmp> Q;$/;"	m	class:SimpIC3::VHeap
Queue	minisat/minisat/mtl/Queue.h	/^    Queue() : buf(1), first(0), end(0) {}$/;"	f	class:Minisat::Queue
Queue	minisat/minisat/mtl/Queue.h	/^class Queue {$/;"	c	namespace:Minisat
REALLOCN	aiger/aiger.c	62;"	d	file:
RLIMIT_AS	minisat/minisat/utils/System.cc	114;"	d	file:
RLIMIT_AS	minisat/minisat/utils/System.cc	130;"	d	file:
Ref	minisat/minisat/mtl/Alloc.h	/^    typedef uint32_t Ref;$/;"	t	class:Minisat::RegionAllocator
Ref_Undef	minisat/minisat/mtl/Alloc.h	/^    enum { Ref_Undef = UINT32_MAX };$/;"	e	enum:Minisat::RegionAllocator::__anon1
RegionAllocator	minisat/minisat/mtl/Alloc.h	/^    explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }$/;"	f	class:Minisat::RegionAllocator
RegionAllocator	minisat/minisat/mtl/Alloc.h	/^class RegionAllocator$/;"	c	namespace:Minisat
S	simpleIC3/ic3/ic3.h	/^	SimpSolver & S;$/;"	m	class:SimpIC3::IC3
SIGINT_exit	minisat/minisat/core/Main.cc	/^static void SIGINT_exit(int) {$/;"	f	file:
SIGINT_exit	minisat/minisat/simp/Main.cc	/^static void SIGINT_exit(int) {$/;"	f	file:
SIGINT_interrupt	minisat/minisat/core/Main.cc	/^static void SIGINT_interrupt(int) { solver->interrupt(); }$/;"	f	file:
SIGINT_interrupt	minisat/minisat/simp/Main.cc	/^static void SIGINT_interrupt(int) { solver->interrupt(); }$/;"	f	file:
SOMAJOR	minisat/Makefile	/^SOMAJOR=2$/;"	m
SOMINOR	minisat/Makefile	/^SOMINOR=1$/;"	m
SORELEASE	minisat/Makefile	/^SORELEASE?=.0#   Declare empty to leave out from library file name.$/;"	m
SRC	makefile	/^SRC = $(wildcard $(IC3DIR)\/*.cpp)$/;"	m
SRCDIR	makefile	/^SRCDIR = $(TOPDIR)\/simpleIC3$/;"	m
SRCS	minisat/Makefile	/^SRCS = $(wildcard minisat\/core\/*.cc) $(wildcard minisat\/simp\/*.cc) $(wildcard minisat\/utils\/*.cc)$/;"	m
ShrinkStackElem	minisat/minisat/core/Solver.h	/^        ShrinkStackElem(uint32_t _i, Lit _l) : i(_i), l(_l){}$/;"	f	struct:Minisat::Solver::ShrinkStackElem
ShrinkStackElem	minisat/minisat/core/Solver.h	/^    struct ShrinkStackElem {$/;"	s	class:Minisat::Solver
SimpIC3	simpleIC3/ic3/Cone.h	/^namespace SimpIC3{$/;"	n
SimpIC3	simpleIC3/ic3/Ternary.h	/^namespace SimpIC3{$/;"	n
SimpIC3	simpleIC3/ic3/ic3.h	/^namespace SimpIC3{$/;"	n
SimpIC3	simpleIC3/ic3/ic3Types.h	/^namespace SimpIC3{$/;"	n
SimpIC3	simpleIC3/ic3/ic3config.h	/^namespace SimpIC3{$/;"	n
SimpIC3	simpleIC3/util/Bitset.h	/^namespace SimpIC3{$/;"	n
SimpIC3	simpleIC3/util/VHeap.h	/^namespace SimpIC3{$/;"	n
SimpSolver	minisat/minisat/simp/SimpSolver.cc	/^SimpSolver::SimpSolver() :$/;"	f	class:SimpSolver
SimpSolver	minisat/minisat/simp/SimpSolver.h	/^class SimpSolver : public Solver {$/;"	c	namespace:Minisat
Size	minisat/minisat/mtl/Vec.h	/^    typedef _Size Size;$/;"	t	class:Minisat::vec
Solver	minisat/minisat/core/Solver.cc	/^Solver::Solver() :$/;"	f	class:Solver
Solver	minisat/minisat/core/Solver.h	/^class Solver {$/;"	c	namespace:Minisat
StreamBuffer	minisat/minisat/utils/ParseUtils.h	/^    explicit StreamBuffer(gzFile i) : in(i), pos(0), size(0){$/;"	f	class:Minisat::StreamBuffer
StreamBuffer	minisat/minisat/utils/ParseUtils.h	/^class StreamBuffer {$/;"	c	namespace:Minisat
StringOption	minisat/minisat/utils/Options.h	/^    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) $/;"	f	class:Minisat::StringOption
StringOption	minisat/minisat/utils/Options.h	/^class StringOption : public Option$/;"	c	namespace:Minisat
TARGET	makefile	/^TARGET = main$/;"	m
TCube	simpleIC3/ic3/ic3Types.h	/^	TCube():frame(-1),parent(nullptr){$/;"	f	struct:SimpIC3::TCube
TCube	simpleIC3/ic3/ic3Types.h	/^	TCube(const TCube & from):frame(from.frame),parent(from.parent){$/;"	f	struct:SimpIC3::TCube
TCube	simpleIC3/ic3/ic3Types.h	/^	TCube(int _frame,TCube * parent):frame(_frame),parent(parent){$/;"	f	struct:SimpIC3::TCube
TCube	simpleIC3/ic3/ic3Types.h	/^	TCube(int _frame,const Minisat::vec<Minisat::Lit> & assign,TCube * parent):frame(_frame),parent(parent){$/;"	f	struct:SimpIC3::TCube
TCube	simpleIC3/ic3/ic3Types.h	/^	TCube(int _frame,const Minisat::vec<Minisat::Lit> & assign,const Minisat::vec<Minisat::Lit> & primary_inputs_assignmnet,TCube * parent):frame(_frame),parent(parent){$/;"	f	struct:SimpIC3::TCube
TCube	simpleIC3/ic3/ic3Types.h	/^struct TCube{$/;"	s	namespace:SimpIC3
TERNARY_H_	simpleIC3/ic3/Ternary.h	23;"	d
TOPDIR	makefile	/^TOPDIR = $(PWD)$/;"	m
Ternary	simpleIC3/ic3/Ternary.cpp	/^	Ternary::Ternary(aiger * _aig,vec<int> * _priority):aig(_aig),priority(_priority){$/;"	f	class:Ternary
Ternary	simpleIC3/ic3/Ternary.h	/^class Ternary{$/;"	c	namespace:SimpIC3
TrailIterator	minisat/minisat/core/SolverTypes.h	/^    TrailIterator(const Lit* _lits) : lits(_lits){}$/;"	f	class:Minisat::TrailIterator
TrailIterator	minisat/minisat/core/SolverTypes.h	/^class TrailIterator {$/;"	c	namespace:Minisat
True	simpleIC3/aiglib/aiglib.h	/^	False,True,Undef$/;"	m	class:aiglib::Value
True	simpleIC3/aiglib/aiglib.h	/^const Literal True =  Literal(aiger_true);$/;"	m	namespace:aiglib
UTIDIR	makefile	/^UTIDIR = $(SRCDIR)\/util$/;"	m
Unit_Size	minisat/minisat/core/SolverTypes.h	/^    enum { Unit_Size = RegionAllocator<uint32_t>::Unit_Size };$/;"	e	enum:Minisat::ClauseAllocator::__anon6
Unit_Size	minisat/minisat/mtl/Alloc.h	/^    enum { Unit_Size = sizeof(T) };$/;"	e	enum:Minisat::RegionAllocator::__anon2
VECTORHEAP_H_	simpleIC3/util/VHeap.h	23;"	d
VERB	minisat/Makefile	/^VERB=$/;"	m
VERB	minisat/Makefile	/^VERB=@$/;"	m
VHeap	simpleIC3/util/VHeap.h	/^    VHeap():sz(0), Q(IntCmp()){$/;"	f	class:SimpIC3::VHeap
VHeap	simpleIC3/util/VHeap.h	/^class VHeap {$/;"	c	namespace:SimpIC3
VMap	minisat/minisat/core/SolverTypes.h	/^template<class T> class VMap : public IntMap<Var, T>{};$/;"	c	namespace:Minisat
Value	simpleIC3/aiglib/aiglib.h	/^enum class Value{$/;"	c	namespace:aiglib
Var	minisat/minisat/core/SolverTypes.h	/^typedef int Var;$/;"	t	namespace:Minisat
VarData	minisat/minisat/core/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	s	class:Minisat::Solver
VarOrderLt	minisat/minisat/core/Solver.h	/^        VarOrderLt(const IntMap<Var, double>&  act) : activity(act) { }$/;"	f	struct:Minisat::Solver::VarOrderLt
VarOrderLt	minisat/minisat/core/Solver.h	/^    struct VarOrderLt {$/;"	s	class:Minisat::Solver
WORD_H_	simpleIC3/aiglib/Word.h	23;"	d
Watcher	minisat/minisat/core/Solver.h	/^        Watcher(CRef cr, Lit p) : cref(cr), blocker(p) {}$/;"	f	struct:Minisat::Solver::Watcher
Watcher	minisat/minisat/core/Solver.h	/^    struct Watcher {$/;"	s	class:Minisat::Solver
WatcherDeleted	minisat/minisat/core/Solver.h	/^        WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}$/;"	f	struct:Minisat::Solver::WatcherDeleted
WatcherDeleted	minisat/minisat/core/Solver.h	/^    struct WatcherDeleted$/;"	s	class:Minisat::Solver
Word	simpleIC3/aiglib/Word.h	/^	Word(Circuit & circuit):circuit(circuit){$/;"	f	class:Word
Word	simpleIC3/aiglib/Word.h	/^	Word(Circuit & circuit,std::vector<Literal>&vals):circuit(circuit){$/;"	f	class:Word
Word	simpleIC3/aiglib/Word.h	/^	Word(Word & from):circuit(from.circuit),data(from.data){$/;"	f	class:Word
Word	simpleIC3/aiglib/Word.h	/^	Word(Word && from):circuit(from.circuit),data(std::move(from.data)){$/;"	f	class:Word
Word	simpleIC3/aiglib/Word.h	/^	Word(const Word & from):circuit(from.circuit),data(from.data){$/;"	f	class:Word
Word	simpleIC3/aiglib/Word.h	/^class Word{$/;"	c
Xnor	simpleIC3/aiglib/aiglib.h	/^	Literal Xnor(Literal a)$/;"	f	class:aiglib::Circuit
Xnor	simpleIC3/aiglib/aiglib.h	/^	Literal Xnor(Literal a, Literal b){$/;"	f	class:aiglib::Circuit
Xnor	simpleIC3/aiglib/aiglib.h	/^	Literal Xnor(Literal a, Literal b, Args... args)$/;"	f	class:aiglib::Circuit
Xnor	simpleIC3/aiglib/aiglib.h	/^	Literal Xnor(const std::list<Literal> & vals){$/;"	f	class:aiglib::Circuit
Xnor	simpleIC3/aiglib/aiglib.h	/^	Literal Xnor(const std::vector<Literal> & vals){$/;"	f	class:aiglib::Circuit
Xor	simpleIC3/aiglib/aiglib.h	/^	Literal Xor(Literal a)$/;"	f	class:aiglib::Circuit
Xor	simpleIC3/aiglib/aiglib.h	/^	Literal Xor(Literal a, Literal b){$/;"	f	class:aiglib::Circuit
Xor	simpleIC3/aiglib/aiglib.h	/^	Literal Xor(Literal a, Literal b, Args... args)$/;"	f	class:aiglib::Circuit
Xor	simpleIC3/aiglib/aiglib.h	/^	Literal Xor(const std::list<Literal> & vals){$/;"	f	class:aiglib::Circuit
Xor	simpleIC3/aiglib/aiglib.h	/^	Literal Xor(const std::vector<Literal> & vals){$/;"	f	class:aiglib::Circuit
_AIGLIB	simpleIC3/aiglib/aiglib.h	23;"	d
_cat	minisat/minisat/core/Solver.cc	/^static const char* _cat = "CORE";$/;"	v	file:
_cat	minisat/minisat/simp/SimpSolver.cc	/^static const char* _cat = "SIMP";$/;"	v	file:
_cat_ic3	simpleIC3/ic3/ic3config.cpp	/^static const char * _cat_ic3 = "IC3";$/;"	v	file:
_insert	minisat/minisat/mtl/Map.h	/^    void   _insert (const K& k, const D& d) { $/;"	f	class:Minisat::Map
abs	minisat/minisat/core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon5
abstractLevel	minisat/minisat/core/Solver.h	/^inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }$/;"	f	class:Minisat::Solver
abstraction	minisat/minisat/core/SolverTypes.h	/^    uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }$/;"	f	class:Minisat::Clause
abstractions	simpleIC3/ic3/ic3.h	/^	vec<uint32_t> abstractions;\/\/abstractions for each clause. -1 if clause has already been subsumed.$/;"	m	class:SimpIC3::IC3
act	minisat/minisat/core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon5
act_vars	simpleIC3/ic3/ic3.h	/^	vec<int> act_vars;$/;"	m	class:SimpIC3::IC3
activations	simpleIC3/ic3/ic3.h	/^	vec<Lit> activations;\/\/activation lits for each clause$/;"	m	class:SimpIC3::IC3
activity	minisat/minisat/core/Solver.h	/^        const IntMap<Var, double>&  activity;$/;"	m	struct:Minisat::Solver::VarOrderLt
activity	minisat/minisat/core/Solver.h	/^    VMap<double>        activity;         \/\/ A heuristic measurement of the activity of a variable.$/;"	m	class:Minisat::Solver
activity	minisat/minisat/core/SolverTypes.h	/^    float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }$/;"	f	class:Minisat::Clause
add	simpleIC3/aiglib/Word.h	/^	Word add(Word   b, Literal & carry_out){$/;"	f	class:Word
add	simpleIC3/aiglib/Word.h	/^	Word add(Word  b){$/;"	f	class:Word
addClause	minisat/minisat/core/Solver.h	/^inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	minisat/minisat/core/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	minisat/minisat/core/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	minisat/minisat/core/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q, Lit r, Lit s){ add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); add_tmp.push(s); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	minisat/minisat/core/Solver.h	/^inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver
addClause	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver
addClause	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver
addClause	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p, Lit q, Lit r, Lit s){ add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); add_tmp.push(s); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver
addClause	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver
addClause_	minisat/minisat/core/Solver.cc	/^bool Solver::addClause_(vec<Lit>& ps)$/;"	f	class:Solver
addClause_	minisat/minisat/simp/SimpSolver.cc	/^bool SimpSolver::addClause_(vec<Lit>& ps)$/;"	f	class:SimpSolver
addEmptyClause	minisat/minisat/core/Solver.h	/^inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addEmptyClause	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::addEmptyClause()                     { add_tmp.clear(); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver
addNewClause	simpleIC3/ic3/ic3.h	/^	void addNewClause(int f, vec<Lit> & cube, bool already_in_solver=false){$/;"	f	class:SimpIC3::IC3
add_tmp	minisat/minisat/core/Solver.h	/^    vec<Lit>            add_tmp;$/;"	m	class:Minisat::Solver
ael	minisat/minisat/core/SolverTypes.h	/^    CRef          ael       (const Clause* t){ return ra.ael((uint32_t*)t); }$/;"	f	class:Minisat::ClauseAllocator
ael	minisat/minisat/mtl/Alloc.h	/^    Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);$/;"	f	class:Minisat::RegionAllocator
aig	simpleIC3/aiglib/aiglib.h	/^	aiger * aig;$/;"	m	class:aiglib::Circuit
aig	simpleIC3/ic3/Ternary.h	/^	 aiger * aig;$/;"	m	class:SimpIC3::Ternary
aiger	aiger/aiger.h	/^struct aiger$/;"	s
aiger	aiger/aiger.h	/^typedef struct aiger aiger;$/;"	t	typeref:struct:aiger
aiger_add_and	aiger/aiger.c	/^aiger_add_and (aiger * public, unsigned lhs, unsigned rhs0, unsigned rhs1)$/;"	f
aiger_add_bad	aiger/aiger.c	/^aiger_add_bad (aiger * public, unsigned lit, const char *name)$/;"	f
aiger_add_comment	aiger/aiger.c	/^aiger_add_comment (aiger * public, const char *comment)$/;"	f
aiger_add_constraint	aiger/aiger.c	/^aiger_add_constraint (aiger * public, unsigned lit, const char *name)$/;"	f
aiger_add_fairness	aiger/aiger.c	/^aiger_add_fairness (aiger * public, unsigned lit, const char *name)$/;"	f
aiger_add_input	aiger/aiger.c	/^aiger_add_input (aiger * public, unsigned lit, const char *name)$/;"	f
aiger_add_justice	aiger/aiger.c	/^aiger_add_justice (aiger * public, $/;"	f
aiger_add_latch	aiger/aiger.c	/^aiger_add_latch (aiger * public,$/;"	f
aiger_add_output	aiger/aiger.c	/^aiger_add_output (aiger * public, unsigned lit, const char *name)$/;"	f
aiger_add_reset	aiger/aiger.c	/^aiger_add_reset (aiger * public, unsigned lit, unsigned reset) $/;"	f
aiger_already_defined	aiger/aiger.c	/^aiger_already_defined (aiger * public, aiger_reader * reader, unsigned lit)$/;"	f	file:
aiger_and	aiger/aiger.h	/^struct aiger_and$/;"	s
aiger_and	aiger/aiger.h	/^typedef struct aiger_and aiger_and;$/;"	t	typeref:struct:aiger_and
aiger_ascii_mode	aiger/aiger.h	/^  aiger_ascii_mode = 1,$/;"	e	enum:aiger_mode
aiger_binary_mode	aiger/aiger.h	/^  aiger_binary_mode = 0,$/;"	e	enum:aiger_mode
aiger_buffer	aiger/aiger.c	/^struct aiger_buffer$/;"	s	file:
aiger_buffer	aiger/aiger.c	/^typedef struct aiger_buffer aiger_buffer;$/;"	t	typeref:struct:aiger_buffer	file:
aiger_check	aiger/aiger.c	/^aiger_check (aiger * public)$/;"	f
aiger_check_bad_defined	aiger/aiger.c	/^aiger_check_bad_defined (aiger_private * private)$/;"	f	file:
aiger_check_constraints_defined	aiger/aiger.c	/^aiger_check_constraints_defined (aiger_private * private)$/;"	f	file:
aiger_check_fairness_defined	aiger/aiger.c	/^aiger_check_fairness_defined (aiger_private * private)$/;"	f	file:
aiger_check_for_cycles	aiger/aiger.c	/^aiger_check_for_cycles (aiger_private * private)$/;"	f	file:
aiger_check_justice_defined	aiger/aiger.c	/^aiger_check_justice_defined (aiger_private * private) $/;"	f	file:
aiger_check_next_defined	aiger/aiger.c	/^aiger_check_next_defined (aiger_private * private)$/;"	f	file:
aiger_check_outputs_defined	aiger/aiger.c	/^aiger_check_outputs_defined (aiger_private * private)$/;"	f	file:
aiger_check_right_hand_side_defined	aiger/aiger.c	/^aiger_check_right_hand_side_defined (aiger_private * private, aiger_and * and,$/;"	f	file:
aiger_check_right_hand_sides_defined	aiger/aiger.c	/^aiger_check_right_hand_sides_defined (aiger_private * private)$/;"	f	file:
aiger_coi	aiger/aiger.c	/^aiger_coi (aiger * public)$/;"	f
aiger_copy_str	aiger/aiger.c	/^aiger_copy_str (aiger_private * private, const char *str)$/;"	f	file:
aiger_default_free	aiger/aiger.c	/^aiger_default_free (void *state, void *ptr, size_t bytes)$/;"	f	file:
aiger_default_get	aiger/aiger.c	/^aiger_default_get (FILE * file)$/;"	f	file:
aiger_default_malloc	aiger/aiger.c	/^aiger_default_malloc (void *state, size_t bytes)$/;"	f	file:
aiger_default_put	aiger/aiger.c	/^aiger_default_put (char ch, FILE * file)$/;"	f	file:
aiger_delete_comments	aiger/aiger.c	/^aiger_delete_comments (aiger * public)$/;"	f	file:
aiger_delete_str	aiger/aiger.c	/^aiger_delete_str (aiger_private * private, char *str)$/;"	f	file:
aiger_delete_symbols	aiger/aiger.c	/^aiger_delete_symbols (aiger_private * private,$/;"	f	file:
aiger_delete_symbols_aux	aiger/aiger.c	/^aiger_delete_symbols_aux (aiger_private * private,$/;"	f	file:
aiger_error	aiger/aiger.c	/^aiger_error (aiger * public)$/;"	f
aiger_error_s	aiger/aiger.c	/^aiger_error_s (aiger_private * private, const char *s, const char *a)$/;"	f	file:
aiger_error_u	aiger/aiger.c	/^aiger_error_u (aiger_private * private, const char *s, unsigned u)$/;"	f	file:
aiger_error_usu	aiger/aiger.c	/^aiger_error_usu (aiger_private * private,$/;"	f	file:
aiger_error_uu	aiger/aiger.c	/^aiger_error_uu (aiger_private * private, const char *s, unsigned a,$/;"	f	file:
aiger_false	aiger/aiger.h	52;"	d
aiger_free	aiger/aiger.h	/^typedef void (*aiger_free) (void *mem_mgr, void *ptr, size_t);$/;"	t
aiger_get	aiger/aiger.h	/^typedef int (*aiger_get) (void *client_state);$/;"	t
aiger_get_symbol	aiger/aiger.c	/^aiger_get_symbol (aiger * public, unsigned lit)$/;"	f
aiger_h_INCLUDED	aiger/aiger.h	31;"	d
aiger_has_suffix	aiger/aiger.c	/^aiger_has_suffix (const char *str, const char *suffix)$/;"	f	file:
aiger_have_at_least_one_symbol	aiger/aiger.c	/^aiger_have_at_least_one_symbol (aiger * public)$/;"	f	file:
aiger_have_at_least_one_symbol_aux	aiger/aiger.c	/^aiger_have_at_least_one_symbol_aux (aiger * public,$/;"	f	file:
aiger_id	aiger/aiger.c	/^aiger_id (void)$/;"	f
aiger_import_literal	aiger/aiger.c	/^aiger_import_literal (aiger_private * private, unsigned lit)$/;"	f	file:
aiger_init	aiger/aiger.c	/^aiger_init (void)$/;"	f
aiger_init_mem	aiger/aiger.c	/^aiger_init_mem (void *memory_mgr,$/;"	f
aiger_is_and	aiger/aiger.c	/^aiger_is_and (aiger * public, unsigned lit)$/;"	f
aiger_is_input	aiger/aiger.c	/^aiger_is_input (aiger * public, unsigned lit)$/;"	f
aiger_is_latch	aiger/aiger.c	/^aiger_is_latch (aiger * public, unsigned lit)$/;"	f
aiger_is_reencoded	aiger/aiger.c	/^aiger_is_reencoded (aiger * public)$/;"	f
aiger_lit2tag	aiger/aiger.c	/^aiger_lit2tag (aiger * public, unsigned lit) $/;"	f
aiger_lit2type	aiger/aiger.c	/^aiger_lit2type (aiger * public, unsigned lit)$/;"	f	file:
aiger_lit2var	aiger/aiger.h	72;"	d
aiger_literal_defined	aiger/aiger.c	/^aiger_literal_defined (aiger_private * private, unsigned lit)$/;"	f	file:
aiger_malloc	aiger/aiger.h	/^typedef void *(*aiger_malloc) (void *mem_mgr, size_t);$/;"	t
aiger_max_input_or_latch	aiger/aiger.c	/^aiger_max_input_or_latch (aiger * public)$/;"	f	file:
aiger_mode	aiger/aiger.h	/^enum aiger_mode$/;"	g
aiger_mode	aiger/aiger.h	/^typedef enum aiger_mode aiger_mode;$/;"	t	typeref:enum:aiger_mode
aiger_new_code	aiger/aiger.c	/^aiger_new_code (unsigned var, unsigned *new, unsigned *code)$/;"	f	file:
aiger_next_ch	aiger/aiger.c	/^aiger_next_ch (aiger_reader * reader)$/;"	f	file:
aiger_not	aiger/aiger.h	61;"	d
aiger_open_and_read_from_file	aiger/aiger.c	/^aiger_open_and_read_from_file (aiger * public, const char *file_name)$/;"	f
aiger_open_and_write_to_file	aiger/aiger.c	/^aiger_open_and_write_to_file (aiger * public, const char *file_name)$/;"	f
aiger_private	aiger/aiger.c	/^struct aiger_private$/;"	s	file:
aiger_private	aiger/aiger.c	/^typedef struct aiger_private aiger_private;$/;"	t	typeref:struct:aiger_private	file:
aiger_put	aiger/aiger.h	/^typedef int (*aiger_put) (char ch, void *client_state);$/;"	t
aiger_put_s	aiger/aiger.c	/^aiger_put_s (void *state, aiger_put put, const char *str)$/;"	f	file:
aiger_put_u	aiger/aiger.c	/^aiger_put_u (void *state, aiger_put put, unsigned u)$/;"	f	file:
aiger_read_ascii	aiger/aiger.c	/^aiger_read_ascii (aiger * public, aiger_reader * reader)$/;"	f	file:
aiger_read_binary	aiger/aiger.c	/^aiger_read_binary (aiger * public, aiger_reader * reader)$/;"	f	file:
aiger_read_comments	aiger/aiger.c	/^aiger_read_comments (aiger * public, aiger_reader * reader)$/;"	f	file:
aiger_read_delta	aiger/aiger.c	/^aiger_read_delta (aiger_private * private, aiger_reader * reader,$/;"	f	file:
aiger_read_from_file	aiger/aiger.c	/^aiger_read_from_file (aiger * public, FILE * file)$/;"	f
aiger_read_generic	aiger/aiger.c	/^aiger_read_generic (aiger * public, void *state, aiger_get get)$/;"	f
aiger_read_header	aiger/aiger.c	/^aiger_read_header (aiger * public, aiger_reader * reader)$/;"	f	file:
aiger_read_literal	aiger/aiger.c	/^aiger_read_literal (aiger_private * private,$/;"	f	file:
aiger_read_number	aiger/aiger.c	/^aiger_read_number (aiger_reader * reader)$/;"	f	file:
aiger_read_symbols_and_comments	aiger/aiger.c	/^aiger_read_symbols_and_comments (aiger * public, aiger_reader * reader)$/;"	f	file:
aiger_reader	aiger/aiger.c	/^struct aiger_reader$/;"	s	file:
aiger_reader	aiger/aiger.c	/^typedef struct aiger_reader aiger_reader;$/;"	t	typeref:struct:aiger_reader	file:
aiger_reader_push_ch	aiger/aiger.c	/^aiger_reader_push_ch (aiger_private * private, aiger_reader * reader, char ch)$/;"	f	file:
aiger_reencode	aiger/aiger.c	/^aiger_reencode (aiger * public)$/;"	f
aiger_reencode_lit	aiger/aiger.c	/^aiger_reencode_lit (aiger * public, unsigned lit,$/;"	f	file:
aiger_reset	aiger/aiger.c	/^aiger_reset (aiger * public)$/;"	f
aiger_sign	aiger/aiger.h	55;"	d
aiger_string_put	aiger/aiger.c	/^aiger_string_put (char ch, aiger_buffer * buffer)$/;"	f	file:
aiger_strip	aiger/aiger.h	58;"	d
aiger_strip_symbols_and_comments	aiger/aiger.c	/^aiger_strip_symbols_and_comments (aiger * public)$/;"	f
aiger_stripped_mode	aiger/aiger.h	/^  aiger_stripped_mode = 2,	\/* can be ORed with one of the previous *\/$/;"	e	enum:aiger_mode
aiger_symbol	aiger/aiger.h	/^struct aiger_symbol$/;"	s
aiger_symbol	aiger/aiger.h	/^typedef struct aiger_symbol aiger_symbol;$/;"	t	typeref:struct:aiger_symbol
aiger_true	aiger/aiger.h	53;"	d
aiger_type	aiger/aiger.c	/^struct aiger_type$/;"	s	file:
aiger_type	aiger/aiger.c	/^typedef struct aiger_type aiger_type;$/;"	t	typeref:struct:aiger_type	file:
aiger_var2lit	aiger/aiger.h	69;"	d
aiger_version	aiger/aiger.c	/^aiger_version (void)$/;"	f
aiger_write_ascii	aiger/aiger.c	/^aiger_write_ascii (aiger * public, void *state, aiger_put put)$/;"	f	file:
aiger_write_binary	aiger/aiger.c	/^aiger_write_binary (aiger * public, void *state, aiger_put put)$/;"	f	file:
aiger_write_comments	aiger/aiger.c	/^aiger_write_comments (aiger * public, void *state, aiger_put put)$/;"	f	file:
aiger_write_comments_to_file	aiger/aiger.c	/^aiger_write_comments_to_file (aiger * public, FILE * file)$/;"	f
aiger_write_delta	aiger/aiger.c	/^aiger_write_delta (void *state, aiger_put put, unsigned delta)$/;"	f	file:
aiger_write_generic	aiger/aiger.c	/^aiger_write_generic (aiger * public,$/;"	f
aiger_write_header	aiger/aiger.c	/^aiger_write_header (aiger * public,$/;"	f	file:
aiger_write_symbols	aiger/aiger.c	/^aiger_write_symbols (aiger * public, void *state, aiger_put put)$/;"	f	file:
aiger_write_symbols_aux	aiger/aiger.c	/^aiger_write_symbols_aux (aiger * public,$/;"	f	file:
aiger_write_symbols_to_file	aiger/aiger.c	/^aiger_write_symbols_to_file (aiger * public, FILE * file)$/;"	f
aiger_write_to_file	aiger/aiger.c	/^aiger_write_to_file (aiger * public, aiger_mode mode, FILE * file)$/;"	f
aiger_write_to_string	aiger/aiger.c	/^aiger_write_to_string (aiger * public, aiger_mode mode, char *str, size_t len)$/;"	f
aiglib	simpleIC3/aiglib/aiglib.h	/^namespace aiglib{$/;"	n
aiglib	simpleIC3/aiglib/aigtocnf.h	/^namespace aiglib{$/;"	n
aigtocnf	simpleIC3/aiglib/aigtocnf.h	/^ Lit aigtocnf(Solver & S, aiger * mgr,vec<Minisat::Lit> & inputs, vec<Minisat::Lit> & in_latches, vec<lbool> & latch_reset, vec<Minisat::Lit> & out_latches, vec<Minisat::Lit> & outputs,vec<Lit> & badStates){$/;"	f	namespace:aiglib
alloc	minisat/minisat/core/SolverTypes.h	/^    CRef alloc(const Clause& from)$/;"	f	class:Minisat::ClauseAllocator
alloc	minisat/minisat/core/SolverTypes.h	/^    CRef alloc(const vec<Lit>& ps, bool learnt = false)$/;"	f	class:Minisat::ClauseAllocator
alloc	minisat/minisat/mtl/Alloc.h	/^RegionAllocator<T>::alloc(int size)$/;"	f	class:Minisat::RegionAllocator
allocatedTCubes	simpleIC3/ic3/ic3Types.h	/^	 static long allocatedTCubes(){$/;"	f	struct:SimpIC3::TCube
analyze	minisat/minisat/core/Solver.cc	/^void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)$/;"	f	class:Solver
analyzeFinal	minisat/minisat/core/Solver.cc	/^void Solver::analyzeFinal(Lit p, LSet& out_conflict)$/;"	f	class:Solver
analyze_stack	minisat/minisat/core/Solver.h	/^    vec<ShrinkStackElem>analyze_stack;$/;"	m	class:Minisat::Solver
analyze_toclear	minisat/minisat/core/Solver.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:Minisat::Solver
and	aiger/aiger.c	/^  unsigned and:1;$/;"	m	struct:aiger_type	file:
ands	aiger/aiger.c	/^  unsigned ands;$/;"	m	struct:aiger_reader	file:
ands	aiger/aiger.h	/^  aiger_and *ands;		\/* [0..num_ands[ *\/$/;"	m	struct:aiger
append	minisat/minisat/mtl/Alg.h	/^static inline void append(const vec<T>& from, vec<T>& to){ copy(from, to, true); }$/;"	f	namespace:Minisat
assignment	simpleIC3/ic3/Ternary.h	/^	lbool assignment(int l){$/;"	f	class:SimpIC3::Ternary
assignment	simpleIC3/ic3/ic3Types.h	/^	Minisat::vec<Minisat::Lit> assignment;$/;"	m	struct:SimpIC3::TCube
assigns	minisat/minisat/core/Solver.h	/^    VMap<lbool>         assigns;          \/\/ The current assignments.$/;"	m	class:Minisat::Solver
assigns	simpleIC3/ic3/Ternary.h	/^	 vec<lbool> assigns;$/;"	m	class:SimpIC3::Ternary
assumptions	minisat/minisat/core/Solver.h	/^    vec<Lit>            assumptions;      \/\/ Current set of assumptions provided to solve by the user.$/;"	m	class:Minisat::Solver
assureLookahead	minisat/minisat/utils/ParseUtils.h	/^    void assureLookahead() {$/;"	f	class:Minisat::StreamBuffer
asymm	minisat/minisat/simp/SimpSolver.cc	/^bool SimpSolver::asymm(Var v, CRef cr)$/;"	f	class:SimpSolver
asymmVar	minisat/minisat/simp/SimpSolver.cc	/^bool SimpSolver::asymmVar(Var v)$/;"	f	class:SimpSolver
asymm_lits	minisat/minisat/simp/SimpSolver.h	/^    int     asymm_lits;$/;"	m	class:Minisat::SimpSolver
asynch_interrupt	minisat/minisat/core/Solver.h	/^    bool                asynch_interrupt;$/;"	m	class:Minisat::Solver
attachClause	minisat/minisat/core/Solver.cc	/^void Solver::attachClause(CRef cr){$/;"	f	class:Solver
backwardSubsumptionCheck	minisat/minisat/simp/SimpSolver.cc	/^bool SimpSolver::backwardSubsumptionCheck(bool verbose)$/;"	f	class:SimpSolver
bad	aiger/aiger.c	/^  unsigned bad;$/;"	m	struct:aiger_reader	file:
bad	aiger/aiger.h	/^  aiger_symbol *bad;		\/* [0..num_bad[ *\/$/;"	m	struct:aiger
begin	minisat/minisat/mtl/IntMap.h	/^        V*       begin  ()       { return &map[0]; }$/;"	f	class:Minisat::IntMap
begin	minisat/minisat/mtl/IntMap.h	/^        const V* begin  () const { return &map[0]; }$/;"	f	class:Minisat::IntMap
begin	minisat/minisat/utils/Options.h	/^    double begin;$/;"	m	struct:Minisat::DoubleRange
begin	minisat/minisat/utils/Options.h	/^    int begin;$/;"	m	struct:Minisat::IntRange
begin	minisat/minisat/utils/Options.h	/^    int64_t begin;$/;"	m	struct:Minisat::Int64Range
begin	simpleIC3/aiglib/Word.h	/^	const Literal* begin() const {$/;"	f	class:Word
begin_inclusive	minisat/minisat/utils/Options.h	/^    bool  begin_inclusive;$/;"	m	struct:Minisat::DoubleRange
bin_op	simpleIC3/aiglib/aiglib.h	/^	Literal bin_op(std::vector<Literal> & store,Literal (Circuit::*f)(Literal,Literal)){$/;"	f	class:aiglib::Circuit
bindir	minisat/Makefile	/^bindir      ?= $(exec_prefix)\/bin$/;"	m
block_cube	simpleIC3/ic3/ic3.h	/^	TCube * block_cube(TCube * B){$/;"	f	class:SimpIC3::IC3
blocker	minisat/minisat/core/Solver.h	/^        Lit  blocker;$/;"	m	struct:Minisat::Solver::Watcher
bucket	minisat/minisat/core/SolverTypes.h	/^    const vec<typename HashTable::Pair>& bucket(int i) const { return map.bucket(i); }$/;"	f	class:Minisat::CMap
bucket	minisat/minisat/mtl/Map.h	/^    const vec<Pair>& bucket(int i) const { return table[i]; }$/;"	f	class:Minisat::Map
bucket_count	minisat/minisat/core/SolverTypes.h	/^    int  bucket_count() const { return map.bucket_count(); }$/;"	f	class:Minisat::CMap
bucket_count	minisat/minisat/mtl/Map.h	/^    int  bucket_count() const { return cap; }$/;"	f	class:Minisat::Map
budgetOff	minisat/minisat/core/Solver.h	/^inline void     Solver::budgetOff(){ conflict_budget = propagation_budget = -1; }$/;"	f	class:Minisat::Solver
buf	minisat/minisat/mtl/Queue.h	/^    vec<T>  buf;$/;"	m	class:Minisat::Queue
buf	minisat/minisat/utils/ParseUtils.h	/^    unsigned char* buf;$/;"	m	class:Minisat::StreamBuffer
buf	simpleIC3/util/Bitset.h	/^    vec<uint64_t>  buf;$/;"	m	class:SimpIC3::Bitset
buffer	aiger/aiger.c	/^  char *buffer;$/;"	m	struct:aiger_reader	file:
buffer_size	minisat/minisat/utils/ParseUtils.h	/^    enum { buffer_size = 64*1024 };$/;"	e	enum:Minisat::StreamBuffer::__anon3
build	minisat/minisat/mtl/Heap.h	/^    void build(const vec<K>& ns) {$/;"	f	class:Minisat::Heap
buildCOI	simpleIC3/ic3/ic3.h	/^	void buildCOI(vec<int> & aiger_lit_property){$/;"	f	class:SimpIC3::IC3
bwdsub_assigns	minisat/minisat/simp/SimpSolver.h	/^    int                 bwdsub_assigns;$/;"	m	class:Minisat::SimpSolver
bwdsub_tmpunit	minisat/minisat/simp/SimpSolver.h	/^    CRef                bwdsub_tmpunit;$/;"	m	class:Minisat::SimpSolver
ca	minisat/minisat/core/Solver.cc	/^    ClauseAllocator& ca;$/;"	m	struct:reduceDB_lt	file:
ca	minisat/minisat/core/Solver.h	/^        const ClauseAllocator& ca;$/;"	m	struct:Minisat::Solver::WatcherDeleted
ca	minisat/minisat/core/Solver.h	/^    ClauseAllocator     ca;$/;"	m	class:Minisat::Solver
ca	minisat/minisat/core/SolverTypes.h	/^    const ClauseAllocator& ca;$/;"	m	class:Minisat::ClauseIterator
ca	minisat/minisat/simp/SimpSolver.h	/^        const ClauseAllocator& ca;$/;"	m	struct:Minisat::SimpSolver::ClauseDeleted
calcAbstraction	minisat/minisat/core/SolverTypes.h	/^    void calcAbstraction() {$/;"	f	class:Minisat::Clause
calcAbstraction	simpleIC3/ic3/ic3.h	/^	uint32_t calcAbstraction(const Lits & ls) {$/;"	f	class:SimpIC3::IC3
cancelUntil	minisat/minisat/core/Solver.cc	/^void Solver::cancelUntil(int level) {$/;"	f	class:Solver
cap	minisat/minisat/mtl/Alloc.h	/^    uint32_t  cap;$/;"	m	class:Minisat::RegionAllocator
cap	minisat/minisat/mtl/Map.h	/^    int        cap;$/;"	m	class:Minisat::Map
cap	minisat/minisat/mtl/Vec.h	/^    Size cap;$/;"	m	class:Minisat::vec
capacity	minisat/minisat/mtl/Alloc.h	/^void RegionAllocator<T>::capacity(uint32_t min_cap)$/;"	f	class:Minisat::RegionAllocator
capacity	minisat/minisat/mtl/Vec.h	/^    int      capacity (void) const   { return cap; }$/;"	f	class:Minisat::vec
capacity	minisat/minisat/mtl/Vec.h	/^void vec<T,_Size>::capacity(Size min_cap) {$/;"	f	class:Minisat::vec
category	minisat/minisat/utils/Options.h	/^    const char* category;$/;"	m	class:Minisat::Option
ccmin_mode	minisat/minisat/core/Solver.h	/^    int       ccmin_mode;         \/\/ Controls conflict clause minimization (0=none, 1=basic, 2=deep).$/;"	m	class:Minisat::Solver
ch	aiger/aiger.c	/^  int ch;$/;"	m	struct:aiger_reader	file:
charno	aiger/aiger.c	/^  unsigned charno;$/;"	m	struct:aiger_reader	file:
checkCEX	simpleIC3/ic3/ic3.h	/^	void checkCEX(vec<Lit> & p,TCube * cex){$/;"	f	class:SimpIC3::IC3
checkCap	minisat/minisat/mtl/Map.h	/^    bool    checkCap(int new_size) const { return new_size > cap; }$/;"	f	class:Minisat::Map
checkGarbage	minisat/minisat/core/Solver.h	/^inline void Solver::checkGarbage(double gf){$/;"	f	class:Minisat::Solver
checkGarbage	minisat/minisat/core/Solver.h	/^inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }$/;"	f	class:Minisat::Solver
checkInvariant	simpleIC3/ic3/ic3.h	/^	void checkInvariant(vec<Lit> & p){$/;"	f	class:SimpIC3::IC3
circuit	simpleIC3/aiglib/Word.h	/^	Circuit & circuit;$/;"	m	class:Word
claBumpActivity	minisat/minisat/core/Solver.h	/^inline void Solver::claBumpActivity (Clause& c) {$/;"	f	class:Minisat::Solver
claDecayActivity	minisat/minisat/core/Solver.h	/^inline void Solver::claDecayActivity() { cla_inc *= (1 \/ clause_decay); }$/;"	f	class:Minisat::Solver
cla_inc	minisat/minisat/core/Solver.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:Minisat::Solver
clauseWord32Size	minisat/minisat/core/SolverTypes.h	/^    static uint32_t clauseWord32Size(int size, bool has_extra){$/;"	f	class:Minisat::ClauseAllocator
clause_decay	minisat/minisat/core/Solver.h	/^    double    clause_decay;$/;"	m	class:Minisat::Solver
clause_frame	simpleIC3/ic3/ic3.h	/^	vec<int> clause_frame;\/\/frame that each clause belongs to$/;"	m	class:SimpIC3::IC3
clause_lim	minisat/minisat/simp/SimpSolver.h	/^    int     clause_lim;        \/\/ Variables are not eliminated if it produces a resolvent with a length above this limit.$/;"	m	class:Minisat::SimpSolver
clauses	minisat/minisat/core/Solver.h	/^    vec<CRef>           clauses;          \/\/ List of problem clauses.$/;"	m	class:Minisat::Solver
clauses	simpleIC3/ic3/ic3.h	/^	vec<vec<Lit> > clauses;\/\/clauses of proof$/;"	m	class:SimpIC3::IC3
clausesBegin	minisat/minisat/core/Solver.h	/^inline ClauseIterator Solver::clausesBegin() const { return ClauseIterator(ca, &clauses[0]); }$/;"	f	class:Minisat::Solver
clausesEnd	minisat/minisat/core/Solver.h	/^inline ClauseIterator Solver::clausesEnd  () const { return ClauseIterator(ca, &clauses[clauses.size()]); }$/;"	f	class:Minisat::Solver
clauses_literals	minisat/minisat/core/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
clean	minisat/minisat/core/SolverTypes.h	/^void OccLists<K,Vec,Deleted,MkIndex>::clean(const K& idx)$/;"	f	class:Minisat::OccLists
cleanAll	minisat/minisat/core/SolverTypes.h	/^void OccLists<K,Vec,Deleted,MkIndex>::cleanAll()$/;"	f	class:Minisat::OccLists
clear	minisat/minisat/core/SolverTypes.h	/^    void     clear       ()                           { map.clear(); }$/;"	f	class:Minisat::CMap
clear	minisat/minisat/core/SolverTypes.h	/^    void  clear(bool free = true){$/;"	f	class:Minisat::OccLists
clear	minisat/minisat/mtl/Heap.h	/^    void clear(bool dispose = false) $/;"	f	class:Minisat::Heap
clear	minisat/minisat/mtl/IntMap.h	/^        void     clear       (bool free = false){$/;"	f	class:Minisat::IntSet
clear	minisat/minisat/mtl/IntMap.h	/^        void     clear  (bool dispose = false) { map.clear(dispose); }$/;"	f	class:Minisat::IntMap
clear	minisat/minisat/mtl/Map.h	/^    void clear  () {$/;"	f	class:Minisat::Map
clear	minisat/minisat/mtl/Queue.h	/^    void clear (bool dealloc = false) { buf.clear(dealloc); buf.growTo(1); first = end = 0; }$/;"	f	class:Minisat::Queue
clear	minisat/minisat/mtl/Vec.h	/^void vec<T,_Size>::clear(bool dealloc) {$/;"	f	class:Minisat::vec
clear	simpleIC3/util/Bitset.h	/^    inline void clear(int index){$/;"	f	class:SimpIC3::Bitset
clear	simpleIC3/util/Bitset.h	/^    void clear (bool dealloc = false) { buf.clear(dealloc);sz=0; }$/;"	f	class:SimpIC3::Bitset
clear	simpleIC3/util/VHeap.h	/^    void clear(bool dealloc = false){$/;"	f	class:SimpIC3::VHeap
clearInterrupt	minisat/minisat/core/Solver.h	/^inline void     Solver::clearInterrupt(){ asynch_interrupt = false; }$/;"	f	class:Minisat::Solver
cmp_lhs	aiger/aiger.c	/^cmp_lhs (const void *a, const void *b)$/;"	f	file:
coi	aiger/aiger.c	/^  unsigned char * coi;$/;"	m	struct:aiger_private	file:
coi	simpleIC3/ic3/ic3.h	/^	ConeOfInfluence * coi=nullptr;$/;"	m	class:SimpIC3::IC3
collect	simpleIC3/aiglib/aiglib.h	/^	void collect(std::vector<Literal> & store, Literal a){$/;"	f	class:aiglib::Circuit
collect	simpleIC3/aiglib/aiglib.h	/^	void collect(std::vector<Literal> & store, Literal a, Args... args ){$/;"	f	class:aiglib::Circuit
collectCOI	simpleIC3/ic3/Cone.cpp	/^void ConeOfInfluence::collectCOI( int l,Bitset & store){$/;"	f	class:ConeOfInfluence
comments	aiger/aiger.h	/^  char **comments;		\/* zero terminated *\/$/;"	m	struct:aiger
conflict	minisat/minisat/core/Solver.h	/^    LSet       conflict;          \/\/ If problem is unsatisfiable (possibly under assumptions),$/;"	m	class:Minisat::Solver
conflict_budget	minisat/minisat/core/Solver.h	/^    int64_t             conflict_budget;    \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver
conflicts	minisat/minisat/core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
conflictsWithReset	simpleIC3/ic3/ic3.h	/^	bool conflictsWithReset(vec<Lit> & cube, bool inputs=false){$/;"	f	class:SimpIC3::IC3
constraints	aiger/aiger.c	/^  unsigned constraints;$/;"	m	struct:aiger_reader	file:
constraints	aiger/aiger.h	/^  aiger_symbol *constraints;	\/* [0..num_constraints[ *\/$/;"	m	struct:aiger
contains	simpleIC3/util/VHeap.h	/^    bool contains(int key){$/;"	f	class:SimpIC3::VHeap
copy	minisat/minisat/mtl/Alg.h	/^static inline void copy(const T& from, T& to)$/;"	f	namespace:Minisat
copy	minisat/minisat/mtl/Alg.h	/^static inline void copy(const vec<T>& from, vec<T>& to, bool append = false)$/;"	f	namespace:Minisat
copyFrom	simpleIC3/util/Bitset.h	/^    void copyFrom(const Bitset & from){$/;"	f	class:SimpIC3::Bitset
copyTo	minisat/minisat/mtl/IntMap.h	/^        void     copyTo (IntMap& to) const     { map.copyTo(to.map); to.index = index; }$/;"	f	class:Minisat::IntMap
copyTo	minisat/minisat/mtl/Vec.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (Size i = 0; i < sz; i++) copy[i] = data[i]; }$/;"	f	class:Minisat::vec
copyTo	simpleIC3/util/Bitset.h	/^    void copyTo(Bitset & to) const{$/;"	f	class:SimpIC3::Bitset
cost	minisat/minisat/simp/SimpSolver.h	/^        uint64_t cost  (Var x)        const { return (uint64_t)n_occ[mkLit(x)] * (uint64_t)n_occ[~mkLit(x)]; }$/;"	f	struct:Minisat::SimpSolver::ElimLt
cpuTime	minisat/minisat/utils/System.h	/^static inline double Minisat::cpuTime(void) { return (double)clock() \/ CLOCKS_PER_SEC; }$/;"	f	class:Minisat
cref	minisat/minisat/core/Solver.h	/^        CRef cref;$/;"	m	struct:Minisat::Solver::Watcher
crefs	minisat/minisat/core/SolverTypes.h	/^    const CRef*            crefs;$/;"	m	class:Minisat::ClauseIterator
cur_coi	simpleIC3/ic3/ic3.h	/^	Bitset cur_coi;$/;"	m	class:SimpIC3::IC3
cursor	aiger/aiger.c	/^  char *cursor;$/;"	m	struct:aiger_buffer	file:
data	minisat/minisat/core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	class:Minisat::Clause	typeref:union:Minisat::Clause::__anon5
data	minisat/minisat/mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair
data	minisat/minisat/mtl/Vec.h	/^    T*   data;$/;"	m	class:Minisat::vec
data	simpleIC3/aiglib/Word.h	/^	std::vector<Literal> data;$/;"	m	class:Word
datarootdir	minisat/Makefile	/^datarootdir ?= $(prefix)\/share$/;"	m
debug	minisat/minisat/core/SolverTypes.h	/^    void debug(){$/;"	f	class:Minisat::CMap
dec	simpleIC3/aiglib/Word.h	/^	Word dec(){$/;"	f	class:Word
dec_vars	minisat/minisat/core/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
decision	minisat/minisat/core/Solver.h	/^    VMap<char>          decision;         \/\/ Declares if a variable is eligible for selection in the decision heuristic.$/;"	m	class:Minisat::Solver
decisionLevel	minisat/minisat/core/Solver.h	/^inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }$/;"	f	class:Minisat::Solver
decisions	minisat/minisat/core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
decrease	minisat/minisat/mtl/Heap.h	/^    void decrease  (K k) { assert(inHeap(k)); percolateUp  (indices[k]); }$/;"	f	class:Minisat::Heap
deleted	minisat/minisat/core/SolverTypes.h	/^    Deleted                  deleted;$/;"	m	class:Minisat::OccLists
demux	simpleIC3/aiglib/Word.h	/^	Word demux(){$/;"	f	class:Word
demux_2to4	simpleIC3/aiglib/Word.h	/^	 Word demux_2to4(Literal a, Literal b){$/;"	f	class:Word
demux_3to8	simpleIC3/aiglib/Word.h	/^	 Word demux_3to8(Literal a, Literal b,Literal c){$/;"	f	class:Word
demux_4to16	simpleIC3/aiglib/Word.h	/^	 Word demux_4to16(Literal a, Literal b,Literal c, Literal d){$/;"	f	class:Word
demux_8to256	simpleIC3/aiglib/Word.h	/^	 Word demux_8to256(Literal a, Literal b,Literal c, Literal d,Literal e, Literal f,Literal g, Literal h){$/;"	f	class:Word
depth	simpleIC3/ic3/ic3.h	/^	int depth(){$/;"	f	class:SimpIC3::IC3
deref	simpleIC3/ic3/ic3Types.h	/^	bool deref(){$/;"	f	struct:SimpIC3::TCube
description	minisat/minisat/utils/Options.h	/^    const char* description;$/;"	m	class:Minisat::Option
detachClause	minisat/minisat/core/Solver.cc	/^void Solver::detachClause(CRef cr, bool strict){$/;"	f	class:Solver
dirties	minisat/minisat/core/SolverTypes.h	/^    vec<K>                   dirties;$/;"	m	class:Minisat::OccLists
dirty	minisat/minisat/core/SolverTypes.h	/^    IntMap<K, char, MkIndex> dirty;$/;"	m	class:Minisat::OccLists
done_with_reading_header	aiger/aiger.c	/^  int done_with_reading_header;$/;"	m	struct:aiger_reader	file:
drand	minisat/minisat/core/Solver.h	/^    static inline double drand(double& seed) {$/;"	f	class:Minisat::Solver
drand	minisat/minisat/mtl/Rnd.h	/^static inline double drand(double& seed)$/;"	f	namespace:Minisat
eagerMatch	minisat/minisat/utils/ParseUtils.h	/^static bool eagerMatch(B& in, const char* str) {$/;"	f	namespace:Minisat
elements	simpleIC3/util/VHeap.h	/^    vec<vec<T> >  elements;$/;"	m	class:SimpIC3::VHeap
elems	minisat/minisat/mtl/Map.h	/^    int  elems() const { return size; }$/;"	f	class:Minisat::Map
elim_heap	minisat/minisat/simp/SimpSolver.h	/^    Heap<Var,ElimLt>    elim_heap;$/;"	m	class:Minisat::SimpSolver
elimclauses	minisat/minisat/simp/SimpSolver.h	/^    vec<uint32_t>       elimclauses;$/;"	m	class:Minisat::SimpSolver
eliminate	minisat/minisat/simp/SimpSolver.cc	/^bool SimpSolver::eliminate(bool turn_off_elim)$/;"	f	class:SimpSolver
eliminateVar	minisat/minisat/simp/SimpSolver.cc	/^bool SimpSolver::eliminateVar(Var v)$/;"	f	class:SimpSolver
eliminated	minisat/minisat/simp/SimpSolver.h	/^    VMap<char>          eliminated;$/;"	m	class:Minisat::SimpSolver
eliminated_vars	minisat/minisat/simp/SimpSolver.h	/^    int     eliminated_vars;$/;"	m	class:Minisat::SimpSolver
elimorder	minisat/minisat/simp/SimpSolver.h	/^    int                 elimorder;$/;"	m	class:Minisat::SimpSolver
empty	minisat/minisat/mtl/Heap.h	/^    bool empty     ()          const { return heap.size() == 0; }$/;"	f	class:Minisat::Heap
empty	simpleIC3/ic3/Ternary.h	/^	 vec<bool> empty;$/;"	m	class:SimpIC3::Ternary
empty	simpleIC3/util/VHeap.h	/^    bool empty(){$/;"	f	class:SimpIC3::VHeap
end	aiger/aiger.c	/^  char *end;$/;"	m	struct:aiger_buffer	file:
end	minisat/minisat/mtl/IntMap.h	/^        V*       end    ()       { return &map[map.size()]; }$/;"	f	class:Minisat::IntMap
end	minisat/minisat/mtl/IntMap.h	/^        const V* end    () const { return &map[map.size()]; }$/;"	f	class:Minisat::IntMap
end	minisat/minisat/mtl/Queue.h	/^    int     end;$/;"	m	class:Minisat::Queue
end	minisat/minisat/utils/Options.h	/^    double end;$/;"	m	struct:Minisat::DoubleRange
end	minisat/minisat/utils/Options.h	/^    int end;$/;"	m	struct:Minisat::IntRange
end	minisat/minisat/utils/Options.h	/^    int64_t end;$/;"	m	struct:Minisat::Int64Range
end	simpleIC3/aiglib/Word.h	/^	const Literal* end() const {$/;"	f	class:Word
end_inclusive	minisat/minisat/utils/Options.h	/^    bool  end_inclusive;$/;"	m	struct:Minisat::DoubleRange
enqueue	minisat/minisat/core/Solver.h	/^inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }$/;"	f	class:Minisat::Solver
equals	minisat/minisat/mtl/Map.h	/^    E          equals;$/;"	m	class:Minisat::Map
error	aiger/aiger.c	/^  char *error;$/;"	m	struct:aiger_private	file:
exec_prefix	minisat/Makefile	/^exec_prefix ?= $(prefix)$/;"	m
extendModel	minisat/minisat/simp/SimpSolver.cc	/^void SimpSolver::extendModel()$/;"	f	class:SimpSolver
extend_model	minisat/minisat/simp/SimpSolver.h	/^    bool    extend_model;      \/\/ Flag to indicate whether the user needs to look at the full model.$/;"	m	class:Minisat::SimpSolver
extra_clause_field	minisat/minisat/core/SolverTypes.h	/^    bool extra_clause_field;$/;"	m	class:Minisat::ClauseAllocator
fairness	aiger/aiger.c	/^  unsigned fairness;$/;"	m	struct:aiger_reader	file:
fairness	aiger/aiger.h	/^  aiger_symbol *fairness;	\/* [0..num_fairness[ *\/$/;"	m	struct:aiger
fanouts	simpleIC3/ic3/Ternary.h	/^	 vec<vec<int> > fanouts;$/;"	m	class:SimpIC3::Ternary
find	minisat/minisat/mtl/Alg.h	/^static inline bool find(V& ts, const T& t)$/;"	f	namespace:Minisat
first	minisat/minisat/mtl/Queue.h	/^    int     first;$/;"	m	class:Minisat::Queue
frame	simpleIC3/ic3/ic3Types.h	/^	int frame;$/;"	m	struct:SimpIC3::TCube
frames	simpleIC3/ic3/ic3.h	/^	vec<vec<Lit>> frames; \/\/activation lits for each frame$/;"	m	class:SimpIC3::IC3
free	minisat/minisat/core/SolverTypes.h	/^    void free(CRef cid)$/;"	f	class:Minisat::ClauseAllocator
free	minisat/minisat/mtl/Alloc.h	/^    void     free      (int size)    { wasted_ += size; }$/;"	f	class:Minisat::RegionAllocator
free_callback	aiger/aiger.c	/^  aiger_free free_callback;$/;"	m	struct:aiger_private	file:
free_vars	minisat/minisat/core/Solver.h	/^    vec<Var>            free_vars;$/;"	m	class:Minisat::Solver
freezeVar	minisat/minisat/simp/SimpSolver.h	/^inline void SimpSolver::freezeVar(Var v){$/;"	f	class:Minisat::SimpSolver
frozen	minisat/minisat/simp/SimpSolver.h	/^    VMap<char>          frozen;$/;"	m	class:Minisat::SimpSolver
frozen_vars	minisat/minisat/simp/SimpSolver.h	/^    vec<Var>            frozen_vars;$/;"	m	class:Minisat::SimpSolver
garbageCollect	minisat/minisat/core/Solver.cc	/^void Solver::garbageCollect()$/;"	f	class:Solver
garbageCollect	minisat/minisat/simp/SimpSolver.cc	/^void SimpSolver::garbageCollect()$/;"	f	class:SimpSolver
garbage_frac	minisat/minisat/core/Solver.h	/^    double    garbage_frac;       \/\/ The fraction of wasted memory allowed before a garbage collection is triggered.$/;"	m	class:Minisat::Solver
gatherTouchedClauses	minisat/minisat/simp/SimpSolver.cc	/^void SimpSolver::gatherTouchedClauses()$/;"	f	class:SimpSolver
gen_iter	simpleIC3/ic3/ic3.h	/^	int gen_iter =0 ;$/;"	m	class:SimpIC3::IC3
gen_order	simpleIC3/ic3/ic3.h	/^	 vec<int> gen_order;$/;"	m	class:SimpIC3::IC3
generalize	simpleIC3/ic3/ic3.h	/^	bool generalize(vec<Lit> & in_clause, int frame){$/;"	f	class:SimpIC3::IC3
get	aiger/aiger.c	/^  aiger_get get;$/;"	m	struct:aiger_reader	file:
getAIG	simpleIC3/aiglib/aiglib.h	/^	aiger * getAIG(){$/;"	f	class:aiglib::Circuit
getAndGate	simpleIC3/aiglib/aiglib.h	/^	Literal getAndGate(int n){$/;"	f	class:aiglib::Circuit
getAndGateInput	simpleIC3/aiglib/aiglib.h	/^	Literal getAndGateInput(int n, bool get_rhs1=false){$/;"	f	class:aiglib::Circuit
getClauseFrame	simpleIC3/ic3/ic3.h	/^	int getClauseFrame(int clauseN){$/;"	f	class:SimpIC3::IC3
getClauseFromActivation	simpleIC3/ic3/ic3.h	/^	int getClauseFromActivation(Lit activationLit){$/;"	f	class:SimpIC3::IC3
getConstantValue	simpleIC3/aiglib/Word.h	/^	long long getConstantValue()const{$/;"	f	class:Word
getConstraint	simpleIC3/aiglib/aiglib.h	/^	Literal getConstraint(int n){$/;"	f	class:aiglib::Circuit
getFalse	simpleIC3/aiglib/aiglib.h	/^	Literal getFalse()const{$/;"	f	class:aiglib::Circuit
getHelpPrefixString	minisat/minisat/utils/Options.h	/^    static const char*&  getHelpPrefixString() { static const char* help_prefix_str = ""; return help_prefix_str; }$/;"	f	class:Minisat::Option
getInput	simpleIC3/aiglib/aiglib.h	/^	Literal getInput(int n){$/;"	f	class:aiglib::Circuit
getLast	simpleIC3/util/VHeap.h	/^    T & getLast(int key){$/;"	f	class:SimpIC3::VHeap
getLatch	simpleIC3/aiglib/aiglib.h	/^	Literal getLatch(int n, bool next=false){$/;"	f	class:aiglib::Circuit
getLatchReset	simpleIC3/aiglib/aiglib.h	/^	Value getLatchReset(int latchNumber){$/;"	f	class:aiglib::Circuit
getLit	simpleIC3/aiglib/aigtocnf.h	/^ Minisat::Lit getLit(Solver & S, int dimacs){$/;"	f	namespace:aiglib
getLit	simpleIC3/aiglib/aigtocnf.h	/^ Minisat::Lit getLit(Solver & S,const int startVar, aiger * mgr, unsigned lit){$/;"	f	namespace:aiglib
getOptionList	minisat/minisat/utils/Options.h	/^    static vec<Option*>& getOptionList () { static vec<Option*> options; return options; }$/;"	f	class:Minisat::Option
getOutput	simpleIC3/aiglib/aiglib.h	/^	Literal getOutput(int n){$/;"	f	class:aiglib::Circuit
getTrue	simpleIC3/aiglib/aiglib.h	/^	Literal getTrue()const{$/;"	f	class:aiglib::Circuit
getUsageString	minisat/minisat/utils/Options.h	/^    static const char*&  getUsageString() { static const char* usage_str; return usage_str; }$/;"	f	class:Minisat::Option
grow	minisat/minisat/simp/SimpSolver.h	/^    int     grow;              \/\/ Allow a variable elimination step to grow by a number of clauses (default to zero).$/;"	m	class:Minisat::SimpSolver
growTo	minisat/minisat/core/SolverTypes.h	/^    void     growTo      (CRef cr, const T& t){ map.insert(cr, t); } \/\/ NOTE: for compatibility$/;"	f	class:Minisat::CMap
growTo	minisat/minisat/mtl/Vec.h	/^void vec<T,_Size>::growTo(Size size) {$/;"	f	class:Minisat::vec
growTo	minisat/minisat/mtl/Vec.h	/^void vec<T,_Size>::growTo(Size size, const T& pad) {$/;"	f	class:Minisat::vec
growTo	simpleIC3/util/Bitset.h	/^    void growTo(int size){$/;"	f	class:SimpIC3::Bitset
halfAdder	simpleIC3/aiglib/Word.h	/^	Literal halfAdder(Literal a, Literal b, Literal & carry_out){$/;"	f	class:Word
has	minisat/minisat/core/SolverTypes.h	/^    bool     has         (CRef cr, T& t)      { return map.peek(cr, t); }$/;"	f	class:Minisat::CMap
has	minisat/minisat/mtl/IntMap.h	/^        bool     has         (K k) { in_set.reserve(k, 0); return in_set[k]; }$/;"	f	class:Minisat::IntSet
has	minisat/minisat/mtl/IntMap.h	/^        bool     has       (K k) const { return index(k) < map.size(); }$/;"	f	class:Minisat::IntMap
has	minisat/minisat/mtl/Map.h	/^    bool has   (const K& k) const {$/;"	f	class:Minisat::Map
hasInLatches	simpleIC3/ic3/ic3.h	/^	bool hasInLatches(vec<Lit> & lits){$/;"	f	class:SimpIC3::IC3
hasOutLatches	simpleIC3/ic3/ic3.h	/^	bool hasOutLatches(vec<Lit> & lits){$/;"	f	class:SimpIC3::IC3
has_extra	minisat/minisat/core/SolverTypes.h	/^        unsigned has_extra : 1;$/;"	m	struct:Minisat::Clause::__anon4
has_extra	minisat/minisat/core/SolverTypes.h	/^    bool         has_extra   ()      const   { return header.has_extra; }$/;"	f	class:Minisat::Clause
hash	minisat/minisat/mtl/Map.h	/^    H          hash;$/;"	m	class:Minisat::Map
hash	minisat/minisat/mtl/Map.h	/^static inline uint32_t hash(int32_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat
hash	minisat/minisat/mtl/Map.h	/^static inline uint32_t hash(int64_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat
hash	minisat/minisat/mtl/Map.h	/^static inline uint32_t hash(uint32_t x){ return x; }$/;"	f	namespace:Minisat
hash	minisat/minisat/mtl/Map.h	/^static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }$/;"	f	namespace:Minisat
header	minisat/minisat/core/SolverTypes.h	/^        unsigned size      : 27; }                        header;$/;"	m	class:Minisat::Clause	typeref:struct:Minisat::Clause::__anon4
heap	minisat/minisat/mtl/Heap.h	/^    vec<K>                heap;     \/\/ Heap of Keys$/;"	m	class:Minisat::Heap
help	minisat/minisat/utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::BoolOption
help	minisat/minisat/utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::DoubleOption
help	minisat/minisat/utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::Int64Option
help	minisat/minisat/utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::IntOption
help	minisat/minisat/utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::StringOption
i	minisat/minisat/core/Solver.h	/^        uint32_t i;$/;"	m	struct:Minisat::Solver::ShrinkStackElem
idx	aiger/aiger.c	/^  unsigned idx;$/;"	m	struct:aiger_type	file:
implied	minisat/minisat/simp/SimpSolver.cc	/^bool SimpSolver::implied(const vec<Lit>& c)$/;"	f	class:SimpSolver
implies	minisat/minisat/core/Solver.cc	/^bool Solver::implies(const vec<Lit>& assumps, vec<Lit>& out)$/;"	f	class:Solver
in	minisat/minisat/utils/ParseUtils.h	/^    gzFile         in;$/;"	m	class:Minisat::StreamBuffer
inHeap	minisat/minisat/mtl/Heap.h	/^    bool inHeap    (K k)       const { return indices.has(k) && indices[k] >= 0; }$/;"	f	class:Minisat::Heap
inLatchN	simpleIC3/ic3/ic3.h	/^	int inLatchN(Var inlatch){$/;"	f	class:SimpIC3::IC3
inToOut	simpleIC3/ic3/ic3.h	/^	Lit inToOut(Lit inlatch){$/;"	f	class:SimpIC3::IC3
inToOut	simpleIC3/ic3/ic3.h	/^	Var inToOut(Var inlatch){$/;"	f	class:SimpIC3::IC3
inToOut	simpleIC3/ic3/ic3.h	/^	void inToOut(vec<Lit> & lits){$/;"	f	class:SimpIC3::IC3
in_latch_to_index	simpleIC3/ic3/ic3.h	/^	vec<int> in_latch_to_index;$/;"	m	class:SimpIC3::IC3
in_latches	simpleIC3/ic3/ic3.h	/^	vec<Var>&  in_latches;$/;"	m	class:SimpIC3::IC3
in_set	minisat/minisat/mtl/IntMap.h	/^        IntMap<K, char, MkIndex> in_set;$/;"	m	class:Minisat::IntSet
inc	simpleIC3/aiglib/Word.h	/^	Word inc(){$/;"	f	class:Word
includedir	minisat/Makefile	/^includedir  ?= $(prefix)\/include$/;"	m
increase	minisat/minisat/mtl/Heap.h	/^    void increase  (K k) { assert(inHeap(k)); percolateDown(indices[k]); }$/;"	f	class:Minisat::Heap
index	minisat/minisat/mtl/IntMap.h	/^        MkIndex  index;$/;"	m	class:Minisat::IntMap
index	minisat/minisat/mtl/Map.h	/^    int32_t index  (const K& k) const { return hash(k) % cap; }$/;"	f	class:Minisat::Map
indices	minisat/minisat/mtl/Heap.h	/^    IntMap<K,int,MkIndex> indices;  \/\/ Each Key's position (index) in the Heap$/;"	m	class:Minisat::Heap
init	minisat/minisat/core/SolverTypes.h	/^    void  init      (const K& idx){ occs.reserve(idx); occs[idx].clear(); dirty.reserve(idx, 0); }$/;"	f	class:Minisat::OccLists
input	aiger/aiger.c	/^  unsigned input:1;$/;"	m	struct:aiger_type	file:
inputs	aiger/aiger.c	/^  unsigned inputs;$/;"	m	struct:aiger_reader	file:
inputs	aiger/aiger.h	/^  aiger_symbol *inputs;		\/* [0..num_inputs[ *\/$/;"	m	struct:aiger
insert	minisat/minisat/core/SolverTypes.h	/^    void     insert      (CRef cr, const T& t){ map.insert(cr, t); }$/;"	f	class:Minisat::CMap
insert	minisat/minisat/mtl/Heap.h	/^    void insert(K k)$/;"	f	class:Minisat::Heap
insert	minisat/minisat/mtl/IntMap.h	/^        void     insert      (K k) { in_set.reserve(k, 0); if (!in_set[k]) { in_set[k] = 1; xs.push(k); } }$/;"	f	class:Minisat::IntSet
insert	minisat/minisat/mtl/IntMap.h	/^        void     insert (K key, V val)       { reserve(key); operator[](key) = val; }$/;"	f	class:Minisat::IntMap
insert	minisat/minisat/mtl/IntMap.h	/^        void     insert (K key, V val, V pad){ reserve(key, pad); operator[](key) = val; }$/;"	f	class:Minisat::IntMap
insert	minisat/minisat/mtl/Map.h	/^    void insert (const K& k, const D& d) { if (checkCap(size+1)) rehash(); _insert(k, d); size++; }$/;"	f	class:Minisat::Map
insert	minisat/minisat/mtl/Queue.h	/^    void insert(T elem) {   \/\/ INVARIANT: buf[end] is always unused$/;"	f	class:Minisat::Queue
insert	simpleIC3/util/VHeap.h	/^    void insert(int key,const  T & element){$/;"	f	class:SimpIC3::VHeap
insertVarOrder	minisat/minisat/core/Solver.h	/^inline void Solver::insertVarOrder(Var x) {$/;"	f	class:Minisat::Solver
interrupt	minisat/minisat/core/Solver.h	/^inline void     Solver::interrupt(){ asynch_interrupt = true; }$/;"	f	class:Minisat::Solver
invert	simpleIC3/aiglib/Word.h	/^	Word invert()const{$/;"	f	class:Word
irand	minisat/minisat/core/Solver.h	/^    static inline int irand(double& seed, int size) {$/;"	f	class:Minisat::Solver
irand	minisat/minisat/mtl/Rnd.h	/^static inline int irand(double& seed, int size) { return (int)(drand(seed) * size); }$/;"	f	namespace:Minisat
isActivationLit	simpleIC3/ic3/ic3.h	/^	bool isActivationLit(Lit activationLit){$/;"	f	class:SimpIC3::IC3
isBlocked	simpleIC3/ic3/ic3.h	/^	bool isBlocked(int frame, vec<Lit> & assignment, int & blocked_at){$/;"	f	class:SimpIC3::IC3
isConst	simpleIC3/aiglib/Word.h	/^	bool isConst() const{$/;"	f	class:Word
isConst	simpleIC3/aiglib/aiglib.h	/^	bool isConst()const{$/;"	f	struct:aiglib::Literal
isConstFalse	simpleIC3/aiglib/aiglib.h	/^	bool isConstFalse()const{$/;"	f	struct:aiglib::Literal
isConstTrue	simpleIC3/aiglib/aiglib.h	/^	bool isConstTrue()const{$/;"	f	struct:aiglib::Literal
isEliminated	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::isEliminated (Var v) const { return eliminated[v]; }$/;"	f	class:Minisat::SimpSolver
isEof	minisat/minisat/utils/ParseUtils.h	/^static inline bool isEof(StreamBuffer& in) { return *in == EOF;  }$/;"	f	namespace:Minisat
isEof	minisat/minisat/utils/ParseUtils.h	/^static inline bool isEof(const char*   in) { return *in == '\\0'; }$/;"	f	namespace:Minisat
isEqual	simpleIC3/aiglib/Word.h	/^	Literal isEqual(Word w){$/;"	f	class:Word
isInLatch	simpleIC3/ic3/ic3.h	/^	bool isInLatch(Lit l){$/;"	f	class:SimpIC3::IC3
isInLatch	simpleIC3/ic3/ic3.h	/^	bool isInLatch(Var v){$/;"	f	class:SimpIC3::IC3
isNegative	simpleIC3/aiglib/Word.h	/^	Literal isNegative(){$/;"	f	class:Word
isOutLatch	simpleIC3/ic3/ic3.h	/^	bool isOutLatch(Lit l){$/;"	f	class:SimpIC3::IC3
isOutLatch	simpleIC3/ic3/ic3.h	/^	bool isOutLatch(Var v){$/;"	f	class:SimpIC3::IC3
isPositive	simpleIC3/aiglib/Word.h	/^	Literal isPositive(){$/;"	f	class:Word
isPreimage	simpleIC3/ic3/ic3.h	/^	bool isPreimage(vec<Lit> & pre,vec<Lit> & post){$/;"	f	class:SimpIC3::IC3
isRemoved	minisat/minisat/core/Solver.h	/^inline bool     Solver::isRemoved       (CRef cr)         const { return ca[cr].mark() == 1; }$/;"	f	class:Minisat::Solver
isReset	simpleIC3/ic3/ic3.h	/^	bool isReset(vec<Lit> & assignment, bool inputs=false){$/;"	f	class:SimpIC3::IC3
isSubsumedAt	simpleIC3/ic3/ic3.h	/^	bool isSubsumedAt(vec<Lit> & cube, int frame){$/;"	f	class:SimpIC3::IC3
isZero	simpleIC3/aiglib/Word.h	/^	Literal isZero(){$/;"	f	class:Word
is_subsumed	simpleIC3/ic3/ic3.h	/^	vec<bool> is_subsumed;$/;"	m	class:SimpIC3::IC3
iter	simpleIC3/ic3/ic3.h	/^	int iter=0;$/;"	m	class:SimpIC3::IC3
justice	aiger/aiger.c	/^  unsigned justice;$/;"	m	struct:aiger_reader	file:
justice	aiger/aiger.h	/^  aiger_symbol *justice;	\/* [0..num_justice[ *\/$/;"	m	struct:aiger
key	minisat/minisat/mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair
l	minisat/minisat/core/Solver.h	/^        Lit      l;$/;"	m	struct:Minisat::Solver::ShrinkStackElem
l_False	minisat/minisat/core/SolverTypes.h	125;"	d
l_True	minisat/minisat/core/SolverTypes.h	124;"	d
l_Undef	minisat/minisat/core/SolverTypes.h	126;"	d
last	minisat/minisat/core/SolverTypes.h	/^    const Lit&   last        ()      const   { return data[header.size-1].lit; }$/;"	f	class:Minisat::Clause
last	minisat/minisat/mtl/Vec.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:Minisat::vec
last	minisat/minisat/mtl/Vec.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:Minisat::vec
latch	aiger/aiger.c	/^  unsigned latch:1;$/;"	m	struct:aiger_type	file:
latch_coi	simpleIC3/ic3/ic3.h	/^	vec<Bitset> latch_coi;$/;"	m	class:SimpIC3::IC3
latch_in_block	simpleIC3/ic3/ic3.h	/^	vec<bool> latch_in_block;$/;"	m	class:SimpIC3::IC3
latches	aiger/aiger.c	/^  unsigned latches;$/;"	m	struct:aiger_reader	file:
latches	aiger/aiger.h	/^  aiger_symbol *latches;	\/* [0..num_latches[ *\/$/;"	m	struct:aiger
lbool	minisat/minisat/core/SolverTypes.h	/^    explicit lbool(bool x) : value(!x) { }$/;"	f	class:Minisat::lbool
lbool	minisat/minisat/core/SolverTypes.h	/^    explicit lbool(uint8_t v) : value(v) { }$/;"	f	class:Minisat::lbool
lbool	minisat/minisat/core/SolverTypes.h	/^    lbool()       : value(0) { }$/;"	f	class:Minisat::lbool
lbool	minisat/minisat/core/SolverTypes.h	/^class lbool {$/;"	c	namespace:Minisat
lea	minisat/minisat/core/SolverTypes.h	/^    Clause*       lea       (CRef r)         { return (Clause*)ra.lea(r); }$/;"	f	class:Minisat::ClauseAllocator
lea	minisat/minisat/core/SolverTypes.h	/^    const Clause* lea       (CRef r) const   { return (Clause*)ra.lea(r);; }$/;"	f	class:Minisat::ClauseAllocator
lea	minisat/minisat/mtl/Alloc.h	/^    T*       lea       (Ref r)       { assert(r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator
lea	minisat/minisat/mtl/Alloc.h	/^    const T* lea       (Ref r) const { assert(r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator
learnt	minisat/minisat/core/SolverTypes.h	/^        unsigned learnt    : 1;$/;"	m	struct:Minisat::Clause::__anon4
learnt	minisat/minisat/core/SolverTypes.h	/^    bool         learnt      ()      const   { return header.learnt; }$/;"	f	class:Minisat::Clause
learnts	minisat/minisat/core/Solver.h	/^    vec<CRef>           learnts;          \/\/ List of learnt clauses.$/;"	m	class:Minisat::Solver
learnts_literals	minisat/minisat/core/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
learntsize_adjust_cnt	minisat/minisat/core/Solver.h	/^    int                 learntsize_adjust_cnt;$/;"	m	class:Minisat::Solver
learntsize_adjust_confl	minisat/minisat/core/Solver.h	/^    double              learntsize_adjust_confl;$/;"	m	class:Minisat::Solver
learntsize_adjust_inc	minisat/minisat/core/Solver.h	/^    double    learntsize_adjust_inc;$/;"	m	class:Minisat::Solver
learntsize_adjust_start_confl	minisat/minisat/core/Solver.h	/^    int       learntsize_adjust_start_confl;$/;"	m	class:Minisat::Solver
learntsize_factor	minisat/minisat/core/Solver.h	/^    double    learntsize_factor;  \/\/ The intitial limit for learnt clauses is a factor of the original clauses.                (default 1 \/ 3)$/;"	m	class:Minisat::Solver
learntsize_inc	minisat/minisat/core/Solver.h	/^    double    learntsize_inc;     \/\/ The limit for learnt clauses is multiplied with this factor each restart.                 (default 1.1)$/;"	m	class:Minisat::Solver
left	minisat/minisat/mtl/Heap.h	/^    static inline int left  (int i) { return i*2+1; }$/;"	f	class:Minisat::Heap
level	minisat/minisat/core/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::Solver::VarData
level	minisat/minisat/core/Solver.h	/^inline int  Solver::level (Var x) const { return vardata[x].level; }$/;"	f	class:Minisat::Solver
lhs	aiger/aiger.h	/^  unsigned lhs;			\/* as literal [2..2*maxvar], even *\/$/;"	m	struct:aiger_and
libdir	minisat/Makefile	/^libdir      ?= $(exec_prefix)\/lib$/;"	m
limitMemory	minisat/minisat/utils/System.cc	/^void Minisat::limitMemory(uint64_t \/*max_mem_mb*\/)$/;"	f	class:Minisat
limitMemory	minisat/minisat/utils/System.cc	/^void Minisat::limitMemory(uint64_t max_mem_mb)$/;"	f	class:Minisat
limitTime	minisat/minisat/utils/System.cc	/^void Minisat::limitTime(uint32_t \/*max_cpu_time*\/)$/;"	f	class:Minisat
limitTime	minisat/minisat/utils/System.cc	/^void Minisat::limitTime(uint32_t max_cpu_time)$/;"	f	class:Minisat
lineno	aiger/aiger.c	/^  unsigned lineno;$/;"	m	struct:aiger_reader	file:
lineno_at_last_token_start	aiger/aiger.c	/^  unsigned lineno_at_last_token_start;$/;"	m	struct:aiger_reader	file:
lit	aiger/aiger.h	/^  unsigned lit;			\/* as literal [0..2*maxvar+1] *\/$/;"	m	struct:aiger_symbol
lit	minisat/minisat/core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon5
lit2int	simpleIC3/aiglib/aigtocnf.h	/^lit2int (aiger * mgr, unsigned a, int startVar)$/;"	f	namespace:aiglib
litRedundant	minisat/minisat/core/Solver.cc	/^bool Solver::litRedundant(Lit p)$/;"	f	class:Solver
lit_Error	minisat/minisat/core/SolverTypes.h	/^const Lit lit_Error = { -1 };  \/\/ }$/;"	m	namespace:Minisat
lit_True	simpleIC3/ic3/ic3.h	/^	Lit lit_True;$/;"	m	class:SimpIC3::IC3
lit_Undef	minisat/minisat/core/SolverTypes.h	/^const Lit lit_Undef = { -2 };  \/\/ }- Useful special constants.$/;"	m	namespace:Minisat
lit_to_clause	simpleIC3/ic3/ic3.h	/^	vec<int> lit_to_clause;\/\/gets the clause corresponding to an activation variable$/;"	m	class:SimpIC3::IC3
lits	aiger/aiger.h	/^  unsigned size, * lits;	\/* used only for justice *\/$/;"	m	struct:aiger_symbol
lits	minisat/minisat/core/SolverTypes.h	/^    const Lit* lits;$/;"	m	class:Minisat::TrailIterator
lits_to_keep	simpleIC3/ic3/ic3.h	/^	vec<bool> lits_to_keep;$/;"	m	class:SimpIC3::IC3
locked	minisat/minisat/core/Solver.h	/^inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }$/;"	f	class:Minisat::Solver
logical_rshift	simpleIC3/aiglib/Word.h	/^	Word logical_rshift(int arg)const{$/;"	f	class:Word
looks_like_aag	aiger/aiger.c	/^  int looks_like_aag;$/;"	m	struct:aiger_reader	file:
lookup	minisat/minisat/core/SolverTypes.h	/^    Vec&  lookup    (const K& idx){ if (dirty[idx]) clean(idx); return occs[idx]; }$/;"	f	class:Minisat::OccLists
lshift	simpleIC3/aiglib/Word.h	/^	Word lshift(int arg)const{$/;"	f	class:Word
lt	minisat/minisat/mtl/Heap.h	/^    Comp                  lt;       \/\/ The heap is a minimum-heap with respect to this comparator$/;"	m	class:Minisat::Heap
luby	minisat/minisat/core/Solver.cc	/^static double luby(double y, int x){$/;"	f	file:
luby_restart	minisat/minisat/core/Solver.h	/^    bool      luby_restart;$/;"	m	class:Minisat::Solver
main	minisat/minisat/core/Main.cc	/^int main(int argc, char** argv)$/;"	f
main	minisat/minisat/simp/Main.cc	/^int main(int argc, char** argv)$/;"	f
main	simpleIC3/main.cpp	/^int main(int argc,char** argv){$/;"	f
main_iteration	simpleIC3/ic3/ic3.h	/^	int main_iteration=0;$/;"	m	class:SimpIC3::IC3
makeConstant	simpleIC3/aiglib/Word.h	/^	static Word makeConstant(Circuit & circuit, int wordSize, long const_val){$/;"	f	class:Word
makeFreeWord	simpleIC3/aiglib/Word.h	/^	static Word makeFreeWord(Circuit & circuit, int wordSize){$/;"	f	class:Word
makeInputWord	simpleIC3/aiglib/Word.h	/^	static Word makeInputWord(Circuit & circuit, int wordSize){$/;"	f	class:Word
makeLatch	simpleIC3/aiglib/aiglib.h	/^	int makeLatch(Literal previous,Literal next, Value initialValue = Value::False,const char * symbol=""){$/;"	f	class:aiglib::Circuit
malloc_callback	aiger/aiger.c	/^  aiger_malloc malloc_callback;$/;"	m	struct:aiger_private	file:
mandir	minisat/Makefile	/^mandir      ?= $(datarootdir)\/man$/;"	m
map	minisat/minisat/core/SolverTypes.h	/^    HashTable map;$/;"	m	class:Minisat::CMap
map	minisat/minisat/mtl/IntMap.h	/^        vec<V>   map;$/;"	m	class:Minisat::IntMap
mapVar	minisat/minisat/core/Solver.cc	/^static Var mapVar(Var x, vec<Var>& map, Var& max)$/;"	f	file:
mark	aiger/aiger.c	/^  unsigned mark:1;$/;"	m	struct:aiger_type	file:
mark	minisat/minisat/core/SolverTypes.h	/^        unsigned mark      : 2;$/;"	m	struct:Minisat::Clause::__anon4
mark	minisat/minisat/core/SolverTypes.h	/^    uint32_t     mark        ()      const   { return header.mark; }$/;"	f	class:Minisat::Clause
mark	minisat/minisat/core/SolverTypes.h	/^    void         mark        (uint32_t m)    { header.mark = m; }$/;"	f	class:Minisat::Clause
markCone	simpleIC3/ic3/Cone.cpp	/^void ConeOfInfluence::markCone( int l){$/;"	f	class:ConeOfInfluence
markSubsumed	simpleIC3/ic3/ic3.h	/^	void markSubsumed(vec<Lit> & gen,uint32_t abstraction, int frame, int start=0){$/;"	f	class:SimpIC3::IC3
match	minisat/minisat/utils/ParseUtils.h	/^static bool match(B& in, const char* str) {$/;"	f	namespace:Minisat
max	minisat/minisat/mtl/Vec.h	/^    static inline Size max(Size x, Size y){ return (x > y) ? x : y; }$/;"	f	class:Minisat::vec
max_learnts	minisat/minisat/core/Solver.h	/^    double              max_learnts;$/;"	m	class:Minisat::Solver
max_literals	minisat/minisat/core/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
max_primary_input	simpleIC3/ic3/Ternary.h	/^	 int max_primary_input;$/;"	m	class:SimpIC3::Ternary
max_simp_var	minisat/minisat/simp/SimpSolver.h	/^    Var                 max_simp_var;        \/\/ Max variable at the point simplification was turned off.$/;"	m	class:Minisat::SimpSolver
maxvar	aiger/aiger.c	/^  unsigned maxvar;$/;"	m	struct:aiger_reader	file:
maxvar	aiger/aiger.h	/^  unsigned maxvar;$/;"	m	struct:aiger
memReadPeak	minisat/minisat/utils/System.cc	/^static inline int memReadPeak(void)$/;"	f	file:
memReadStat	minisat/minisat/utils/System.cc	/^static inline int memReadStat(int field)$/;"	f	file:
memUsed	minisat/minisat/utils/System.cc	/^double Minisat::memUsed()     { return 0; }$/;"	f	class:Minisat
memUsed	minisat/minisat/utils/System.cc	/^double Minisat::memUsed() { return (double)memReadStat(0) * (double)getpagesize() \/ (1024*1024); }$/;"	f	class:Minisat
memUsed	minisat/minisat/utils/System.cc	/^double Minisat::memUsed() {$/;"	f	class:Minisat
memUsedPeak	minisat/minisat/utils/System.cc	/^double Minisat::memUsedPeak() { return 0; }$/;"	f	class:Minisat
memUsedPeak	minisat/minisat/utils/System.cc	/^double Minisat::memUsedPeak() { return memUsed(); }$/;"	f	class:Minisat
memUsedPeak	minisat/minisat/utils/System.cc	/^double Minisat::memUsedPeak(bool strictlyPeak) { $/;"	f	class:Minisat
memory	minisat/minisat/mtl/Alloc.h	/^    T*        memory;$/;"	m	class:Minisat::RegionAllocator
memory_mgr	aiger/aiger.c	/^  void *memory_mgr;$/;"	m	struct:aiger_private	file:
memset	simpleIC3/util/Bitset.h	/^    void memset(bool to){$/;"	f	class:SimpIC3::Bitset
merge	minisat/minisat/simp/SimpSolver.cc	/^bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, int& size)$/;"	f	class:SimpSolver
merge	minisat/minisat/simp/SimpSolver.cc	/^bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)$/;"	f	class:SimpSolver
merges	minisat/minisat/simp/SimpSolver.h	/^    int     merges;$/;"	m	class:Minisat::SimpSolver
mgr	simpleIC3/ic3/Cone.h	/^	aiger* mgr;$/;"	m	class:SimpIC3::ConeOfInfluence
mgr	simpleIC3/ic3/ic3.h	/^	aiger * mgr;$/;"	m	class:SimpIC3::IC3
min_learnts_lim	minisat/minisat/core/Solver.h	/^    int       min_learnts_lim;    \/\/ Minimum number to set the learnts limit to.$/;"	m	class:Minisat::Solver
min_primary_input	simpleIC3/ic3/Ternary.h	/^	 int min_primary_input;$/;"	m	class:SimpIC3::Ternary
mkElimClause	minisat/minisat/simp/SimpSolver.cc	/^static void mkElimClause(vec<uint32_t>& elimclauses, Lit x)$/;"	f	file:
mkElimClause	minisat/minisat/simp/SimpSolver.cc	/^static void mkElimClause(vec<uint32_t>& elimclauses, Var v, Clause& c)$/;"	f	file:
mkLit	minisat/minisat/core/SolverTypes.h	/^inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }$/;"	f	namespace:Minisat
mkVarData	minisat/minisat/core/Solver.h	/^    static inline VarData mkVarData(CRef cr, int l){ VarData d = {cr, l}; return d; }$/;"	f	class:Minisat::Solver
mode	aiger/aiger.c	/^  aiger_mode mode;$/;"	m	struct:aiger_reader	file:
model	minisat/minisat/core/Solver.h	/^    vec<lbool> model;             \/\/ If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:Minisat::Solver
modelValue	minisat/minisat/core/Solver.h	/^inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver
modelValue	minisat/minisat/core/Solver.h	/^inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }$/;"	f	class:Minisat::Solver
moveInvariantToEnd	simpleIC3/ic3/ic3.h	/^	void moveInvariantToEnd(int from){$/;"	f	class:SimpIC3::IC3
moveTo	minisat/minisat/core/SolverTypes.h	/^    void moveTo(CMap& other){ map.moveTo(other.map); }$/;"	f	class:Minisat::CMap
moveTo	minisat/minisat/core/SolverTypes.h	/^    void moveTo(ClauseAllocator& to){$/;"	f	class:Minisat::ClauseAllocator
moveTo	minisat/minisat/mtl/Alloc.h	/^    void     moveTo(RegionAllocator& to) {$/;"	f	class:Minisat::RegionAllocator
moveTo	minisat/minisat/mtl/IntMap.h	/^        void     moveTo (IntMap& to)           { map.moveTo(to.map); to.index = index; }$/;"	f	class:Minisat::IntMap
moveTo	minisat/minisat/mtl/Map.h	/^    void moveTo(Map& other){$/;"	f	class:Minisat::Map
moveTo	minisat/minisat/mtl/Vec.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:Minisat::vec
nAssigns	minisat/minisat/core/Solver.h	/^inline int      Solver::nAssigns      ()      const   { return trail.size(); }$/;"	f	class:Minisat::Solver
nClauses	minisat/minisat/core/Solver.h	/^inline int      Solver::nClauses      ()      const   { return num_clauses; }$/;"	f	class:Minisat::Solver
nFreeVars	minisat/minisat/core/Solver.h	/^inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }$/;"	f	class:Minisat::Solver
nLearnts	minisat/minisat/core/Solver.h	/^inline int      Solver::nLearnts      ()      const   { return num_learnts; }$/;"	f	class:Minisat::Solver
nVars	minisat/minisat/core/Solver.h	/^inline int      Solver::nVars         ()      const   { return next_var; }$/;"	f	class:Minisat::Solver
n_occ	minisat/minisat/simp/SimpSolver.h	/^        const LMap<int>& n_occ;$/;"	m	struct:Minisat::SimpSolver::ElimLt
n_occ	minisat/minisat/simp/SimpSolver.h	/^    LMap<int>           n_occ;$/;"	m	class:Minisat::SimpSolver
n_touched	minisat/minisat/simp/SimpSolver.h	/^    int                 n_touched;$/;"	m	class:Minisat::SimpSolver
naive_tern	simpleIC3/ic3/ic3.h	/^	Bitset naive_tern;$/;"	m	class:SimpIC3::IC3
name	aiger/aiger.h	/^  char *name;$/;"	m	struct:aiger_symbol
name	minisat/minisat/utils/Options.h	/^    const char* name;$/;"	m	class:Minisat::Option
negate	simpleIC3/aiglib/Word.h	/^	Word negate(){$/;"	f	class:Word
newBadState	simpleIC3/aiglib/aiglib.h	/^	int newBadState(Literal from, const char * symbol=""){$/;"	f	class:aiglib::Circuit
newConstraint	simpleIC3/aiglib/aiglib.h	/^	void newConstraint(Literal p,const char * symbol=""){$/;"	f	class:aiglib::Circuit
newDecisionLevel	minisat/minisat/core/Solver.h	/^inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }$/;"	f	class:Minisat::Solver
newFreeLit	simpleIC3/aiglib/aiglib.h	/^	Literal newFreeLit(){$/;"	f	class:aiglib::Circuit
newInput	simpleIC3/aiglib/aiglib.h	/^	Literal newInput(const char * symbol=""){$/;"	f	class:aiglib::Circuit
newLatch	simpleIC3/aiglib/aiglib.h	/^	Literal newLatch(Literal next, Value initialValue = Value::False,const char * symbol=""){$/;"	f	class:aiglib::Circuit
newOutput	simpleIC3/aiglib/aiglib.h	/^	int newOutput(Literal from, const char * symbol=""){$/;"	f	class:aiglib::Circuit
newVar	minisat/minisat/core/Solver.cc	/^Var Solver::newVar(lbool upol, bool dvar)$/;"	f	class:Solver
newVar	minisat/minisat/simp/SimpSolver.cc	/^Var SimpSolver::newVar(lbool upol, bool dvar) {$/;"	f	class:SimpSolver
next	aiger/aiger.h	/^  unsigned next, reset;		\/* used only for latches *\/$/;"	m	struct:aiger_symbol
next_var	minisat/minisat/core/Solver.h	/^    Var                 next_var;         \/\/ Next variable to be created.$/;"	m	class:Minisat::Solver
nprimes	minisat/minisat/mtl/Map.h	/^static const int nprimes          = 25;$/;"	m	namespace:Minisat
numAnds	simpleIC3/aiglib/aiglib.h	/^	int numAnds()const{$/;"	f	class:aiglib::Circuit
numBadStates	simpleIC3/aiglib/aiglib.h	/^	int numBadStates()const{$/;"	f	class:aiglib::Circuit
numConstraints	simpleIC3/aiglib/aiglib.h	/^	int numConstraints()const{$/;"	f	class:aiglib::Circuit
numInputs	simpleIC3/aiglib/aiglib.h	/^	int numInputs()const{$/;"	f	class:aiglib::Circuit
numLatches	simpleIC3/aiglib/aiglib.h	/^	int numLatches()const{$/;"	f	class:aiglib::Circuit
numOutputs	simpleIC3/aiglib/aiglib.h	/^	int numOutputs()const{$/;"	f	class:aiglib::Circuit
num_ands	aiger/aiger.h	/^  unsigned num_ands;$/;"	m	struct:aiger
num_bad	aiger/aiger.h	/^  unsigned num_bad;$/;"	m	struct:aiger
num_clauses	minisat/minisat/core/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
num_comments	aiger/aiger.c	/^  unsigned num_comments;$/;"	m	struct:aiger_private	file:
num_constraints	aiger/aiger.h	/^  unsigned num_constraints;$/;"	m	struct:aiger
num_fail_blocked	simpleIC3/ic3/ic3.h	/^	int num_fail_blocked;$/;"	m	class:SimpIC3::IC3
num_fairness	aiger/aiger.h	/^  unsigned num_fairness;$/;"	m	struct:aiger
num_gen	simpleIC3/ic3/ic3.h	/^	int num_gen;$/;"	m	class:SimpIC3::IC3
num_inputs	aiger/aiger.h	/^  unsigned num_inputs;$/;"	m	struct:aiger
num_justice	aiger/aiger.h	/^  unsigned num_justice;$/;"	m	struct:aiger
num_latches	aiger/aiger.h	/^  unsigned num_latches;$/;"	m	struct:aiger
num_learnts	minisat/minisat/core/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
num_outputs	aiger/aiger.h	/^  unsigned num_outputs;$/;"	m	struct:aiger
occs	minisat/minisat/core/SolverTypes.h	/^    IntMap<K, Vec,  MkIndex> occs;$/;"	m	class:Minisat::OccLists
occurs	minisat/minisat/simp/SimpSolver.h	/^                        occurs;$/;"	m	class:Minisat::SimpSolver
ok	minisat/minisat/core/Solver.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:Minisat::Solver
okay	minisat/minisat/core/Solver.h	/^inline bool     Solver::okay          ()      const   { return ok; }$/;"	f	class:Minisat::Solver
one	simpleIC3/aiglib/Word.h	/^	Word one(){$/;"	f	class:Word
ones	simpleIC3/aiglib/Word.h	/^	Word ones(){$/;"	f	class:Word
onstack	aiger/aiger.c	/^  unsigned onstack:1;$/;"	m	struct:aiger_type	file:
operator !=	minisat/minisat/core/Solver.h	/^        bool operator!=(const Watcher& w) const { return cref != w.cref; }$/;"	f	struct:Minisat::Solver::Watcher
operator !=	minisat/minisat/core/SolverTypes.h	/^    bool  operator != (lbool b) const { return !(*this == b); }$/;"	f	class:Minisat::lbool
operator !=	minisat/minisat/core/SolverTypes.h	/^    bool operator != (Lit p) const { return x != p.x; }$/;"	f	struct:Minisat::Lit
operator !=	minisat/minisat/core/SolverTypes.h	/^    bool operator!=(const ClauseIterator& ci) const { return crefs != ci.crefs; }$/;"	f	class:Minisat::ClauseIterator
operator !=	minisat/minisat/core/SolverTypes.h	/^    bool operator!=(const TrailIterator& ti) const { return lits != ti.lits; }$/;"	f	class:Minisat::TrailIterator
operator !=	simpleIC3/aiglib/aiglib.h	/^	bool operator !=(Literal p) const {$/;"	f	struct:aiglib::Literal
operator &	simpleIC3/aiglib/Word.h	/^	Word operator &(const Word a)const{$/;"	f	class:Word
operator &&	minisat/minisat/core/SolverTypes.h	/^    lbool operator && (lbool b) const { $/;"	f	class:Minisat::lbool
operator ()	minisat/minisat/core/Solver.cc	/^    bool operator () (CRef x, CRef y) { $/;"	f	struct:reduceDB_lt
operator ()	minisat/minisat/core/Solver.h	/^        bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }$/;"	f	struct:Minisat::Solver::VarOrderLt
operator ()	minisat/minisat/core/Solver.h	/^        bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }$/;"	f	struct:Minisat::Solver::WatcherDeleted
operator ()	minisat/minisat/core/SolverTypes.h	/^        uint32_t operator()(CRef cr) const { return (uint32_t)cr; } };$/;"	f	struct:Minisat::CMap::CRefHash
operator ()	minisat/minisat/core/SolverTypes.h	/^struct MkIndexLit { vec<Lit>::Size operator()(Lit l) const { return vec<Lit>::Size(l.x); } };$/;"	f	struct:Minisat::MkIndexLit
operator ()	minisat/minisat/mtl/IntMap.h	/^        typename vec<T>::Size operator()(T t) const { return (typename vec<T>::Size)t; }$/;"	f	struct:Minisat::MkIndexDefault
operator ()	minisat/minisat/mtl/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	f	struct:Minisat::DeepEqual
operator ()	minisat/minisat/mtl/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	f	struct:Minisat::DeepHash
operator ()	minisat/minisat/mtl/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	f	struct:Minisat::Equal
operator ()	minisat/minisat/mtl/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	f	struct:Minisat::Hash
operator ()	minisat/minisat/mtl/Sort.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:Minisat::LessThan_default
operator ()	minisat/minisat/simp/SimpSolver.h	/^        bool operator()(Var x, Var y) const { return cost(x) < cost(y); }$/;"	f	struct:Minisat::SimpSolver::ElimLt
operator ()	minisat/minisat/simp/SimpSolver.h	/^        bool operator()(const CRef& cr) const { return ca[cr].mark() == 1; } };$/;"	f	struct:Minisat::SimpSolver::ClauseDeleted
operator ()	minisat/minisat/utils/Options.h	/^        bool operator()(const Option* x, const Option* y) {$/;"	f	struct:Minisat::Option::OptionLt
operator ()	simpleIC3/ic3/ic3.h	/^		bool operator () (const Lit & x, const Lit & y){$/;"	f	struct:SimpIC3::IC3::LessThanClause
operator ()	simpleIC3/util/VHeap.h	/^    	 bool operator()(int a, int b)const{$/;"	f	struct:SimpIC3::VHeap::IntCmp
operator *	minisat/minisat/core/SolverTypes.h	/^    Lit  operator*() const { return *lits; }$/;"	f	class:Minisat::TrailIterator
operator *	minisat/minisat/core/SolverTypes.h	/^    const Clause& operator*() const { return ca[*crefs]; }$/;"	f	class:Minisat::ClauseIterator
operator *	minisat/minisat/utils/ParseUtils.h	/^    int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }$/;"	f	class:Minisat::StreamBuffer
operator ++	minisat/minisat/core/SolverTypes.h	/^    void operator++()   { lits++; }$/;"	f	class:Minisat::TrailIterator
operator ++	minisat/minisat/core/SolverTypes.h	/^    void operator++(){ crefs++; }$/;"	f	class:Minisat::ClauseIterator
operator ++	minisat/minisat/utils/ParseUtils.h	/^    void operator ++ ()       { pos++; assureLookahead(); }$/;"	f	class:Minisat::StreamBuffer
operator <	minisat/minisat/core/SolverTypes.h	/^    bool operator <  (Lit p) const { return x < p.x;  } \/\/ '<' makes p, ~p adjacent in the ordering.$/;"	f	struct:Minisat::Lit
operator <	simpleIC3/aiglib/aiglib.h	/^	bool operator <(Literal p) const {$/;"	f	struct:aiglib::Literal
operator =	minisat/minisat/utils/Options.h	/^    BoolOption& operator=(bool b)     { value = b; return *this; }$/;"	f	class:Minisat::BoolOption
operator =	minisat/minisat/utils/Options.h	/^    DoubleOption& operator=(double x)   { value = x; return *this; }$/;"	f	class:Minisat::DoubleOption
operator =	minisat/minisat/utils/Options.h	/^    Int64Option& operator= (int64_t x)  { value = x; return *this; }$/;"	f	class:Minisat::Int64Option
operator =	minisat/minisat/utils/Options.h	/^    IntOption& operator= (int32_t x)  { value = x; return *this; }$/;"	f	class:Minisat::IntOption
operator =	minisat/minisat/utils/Options.h	/^    StringOption& operator=    (const char* x)  { value = x; return *this; }$/;"	f	class:Minisat::StringOption
operator =	simpleIC3/aiglib/Word.h	/^	Word& operator=(const Word& other) {$/;"	f	class:Word
operator ==	minisat/minisat/core/Solver.h	/^        bool operator==(const Watcher& w) const { return cref == w.cref; }$/;"	f	struct:Minisat::Solver::Watcher
operator ==	minisat/minisat/core/SolverTypes.h	/^    bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }$/;"	f	class:Minisat::lbool
operator ==	minisat/minisat/core/SolverTypes.h	/^    bool operator == (Lit p) const { return x == p.x; }$/;"	f	struct:Minisat::Lit
operator ==	minisat/minisat/core/SolverTypes.h	/^    bool operator==(const ClauseIterator& ci) const { return crefs == ci.crefs; }$/;"	f	class:Minisat::ClauseIterator
operator ==	minisat/minisat/core/SolverTypes.h	/^    bool operator==(const TrailIterator& ti) const { return lits == ti.lits; }$/;"	f	class:Minisat::TrailIterator
operator ==	simpleIC3/aiglib/aiglib.h	/^	bool operator ==(Literal p) const {$/;"	f	struct:aiglib::Literal
operator T*	minisat/minisat/mtl/Vec.h	/^    operator T*       (void)           { return data; }$/;"	f	class:Minisat::vec
operator []	minisat/minisat/core/SolverTypes.h	/^    Clause&       operator[](CRef r)         { return (Clause&)ra[r]; }$/;"	f	class:Minisat::ClauseAllocator
operator []	minisat/minisat/core/SolverTypes.h	/^    Lit          operator [] (int i) const   { return data[i].lit; }$/;"	f	class:Minisat::Clause
operator []	minisat/minisat/core/SolverTypes.h	/^    Lit&         operator [] (int i)         { return data[i].lit; }$/;"	f	class:Minisat::Clause
operator []	minisat/minisat/core/SolverTypes.h	/^    T&       operator [] (CRef cr)            { return map[cr]; }$/;"	f	class:Minisat::CMap
operator []	minisat/minisat/core/SolverTypes.h	/^    Vec&  operator[](const K& idx){ return occs[idx]; }$/;"	f	class:Minisat::OccLists
operator []	minisat/minisat/core/SolverTypes.h	/^    const Clause& operator[](CRef r) const   { return (Clause&)ra[r]; }$/;"	f	class:Minisat::ClauseAllocator
operator []	minisat/minisat/core/SolverTypes.h	/^    const T& operator [] (CRef cr) const      { return map[cr]; }$/;"	f	class:Minisat::CMap
operator []	minisat/minisat/mtl/Alloc.h	/^    T&       operator[](Ref r)       { assert(r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator
operator []	minisat/minisat/mtl/Alloc.h	/^    const T& operator[](Ref r) const { assert(r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator
operator []	minisat/minisat/mtl/Heap.h	/^    int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }$/;"	f	class:Minisat::Heap
operator []	minisat/minisat/mtl/IntMap.h	/^        K        operator [] (int index) const  { return xs[index]; }$/;"	f	class:Minisat::IntSet
operator []	minisat/minisat/mtl/IntMap.h	/^        V&       operator[](K k)       { assert(has(k)); return map[index(k)]; }$/;"	f	class:Minisat::IntMap
operator []	minisat/minisat/mtl/IntMap.h	/^        const V& operator[](K k) const { assert(has(k)); return map[index(k)]; }$/;"	f	class:Minisat::IntMap
operator []	minisat/minisat/mtl/Map.h	/^    D& operator [] (const K& k)$/;"	f	class:Minisat::Map
operator []	minisat/minisat/mtl/Map.h	/^    const D& operator [] (const K& k) const$/;"	f	class:Minisat::Map
operator []	minisat/minisat/mtl/Queue.h	/^    T&       operator [] (int index)        { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Minisat::Queue
operator []	minisat/minisat/mtl/Queue.h	/^    const T& operator [] (int index) const  { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Minisat::Queue
operator []	minisat/minisat/mtl/Vec.h	/^    T&       operator [] (Size index)       { return data[index]; }$/;"	f	class:Minisat::vec
operator []	minisat/minisat/mtl/Vec.h	/^    const T& operator [] (Size index) const { return data[index]; }$/;"	f	class:Minisat::vec
operator []	simpleIC3/aiglib/Word.h	/^	Literal operator[](const int i)const{$/;"	f	class:Word
operator []	simpleIC3/util/Bitset.h	/^    inline const bool operator [] (int index) const  {$/;"	f	class:SimpIC3::Bitset
operator ^	minisat/minisat/core/SolverTypes.h	/^    lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }$/;"	f	class:Minisat::lbool
operator ^	minisat/minisat/core/SolverTypes.h	/^inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }$/;"	f	namespace:Minisat
operator ^	simpleIC3/aiglib/Word.h	/^	Word operator ^(const Word a)const{$/;"	f	class:Word
operator bool	minisat/minisat/utils/Options.h	/^    operator    bool     (void) const { return value; }$/;"	f	class:Minisat::BoolOption
operator bool&	minisat/minisat/utils/Options.h	/^    operator    bool&    (void)       { return value; }$/;"	f	class:Minisat::BoolOption
operator const Lit*	minisat/minisat/core/SolverTypes.h	/^    operator const Lit* (void) const         { return (Lit*)data; }$/;"	f	class:Minisat::Clause
operator const char*	minisat/minisat/utils/Options.h	/^    operator      const char*  (void) const     { return value; }$/;"	f	class:Minisat::StringOption
operator const char*&	minisat/minisat/utils/Options.h	/^    operator      const char*& (void)           { return value; }$/;"	f	class:Minisat::StringOption
operator double	minisat/minisat/utils/Options.h	/^    operator      double   (void) const { return value; }$/;"	f	class:Minisat::DoubleOption
operator double&	minisat/minisat/utils/Options.h	/^    operator      double&  (void)       { return value; }$/;"	f	class:Minisat::DoubleOption
operator int32_t	minisat/minisat/utils/Options.h	/^    operator   int32_t   (void) const { return value; }$/;"	f	class:Minisat::IntOption
operator int32_t&	minisat/minisat/utils/Options.h	/^    operator   int32_t&  (void)       { return value; }$/;"	f	class:Minisat::IntOption
operator int64_t	minisat/minisat/utils/Options.h	/^    operator     int64_t   (void) const { return value; }$/;"	f	class:Minisat::Int64Option
operator int64_t&	minisat/minisat/utils/Options.h	/^    operator     int64_t&  (void)       { return value; }$/;"	f	class:Minisat::Int64Option
operator |	simpleIC3/aiglib/Word.h	/^	Word operator |(const Word a)const{$/;"	f	class:Word
operator ||	minisat/minisat/core/SolverTypes.h	/^    lbool operator || (lbool b) const {$/;"	f	class:Minisat::lbool
operator ~	minisat/minisat/core/SolverTypes.h	/^inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }$/;"	f	namespace:Minisat
operator ~	simpleIC3/aiglib/Word.h	/^	Word operator ~()const{$/;"	f	class:Word
operator ~	simpleIC3/aiglib/aiglib.h	/^inline Literal operator ~(Literal p) {$/;"	f	namespace:aiglib
opt_coi	simpleIC3/ic3/Cone.h	/^	bool opt_coi=true;$/;"	m	class:SimpIC3::ConeOfInfluence
opt_print_coi	simpleIC3/ic3/Cone.h	/^	bool opt_print_coi=false;$/;"	m	class:SimpIC3::ConeOfInfluence
order	simpleIC3/ic3/ic3.h	/^	vec<int> order;$/;"	m	class:SimpIC3::IC3
order_heap	minisat/minisat/core/Solver.h	/^    Heap<Var,VarOrderLt>order_heap;       \/\/ A priority queue of variables ordered with respect to the variable activity.$/;"	m	class:Minisat::Solver
outLatchN	simpleIC3/ic3/ic3.h	/^	int outLatchN(Var outlatch){$/;"	f	class:SimpIC3::IC3
outToIn	simpleIC3/ic3/ic3.h	/^	Lit outToIn(Lit outlatch){$/;"	f	class:SimpIC3::IC3
outToIn	simpleIC3/ic3/ic3.h	/^	Var outToIn(Var outlatch){$/;"	f	class:SimpIC3::IC3
outToIn	simpleIC3/ic3/ic3.h	/^	void outToIn(vec<Lit> & lits){$/;"	f	class:SimpIC3::IC3
out_latch_to_index	simpleIC3/ic3/ic3.h	/^	vec<int> out_latch_to_index;$/;"	m	class:SimpIC3::IC3
out_latches	simpleIC3/ic3/ic3.h	/^	vec<Var> & out_latches;$/;"	m	class:SimpIC3::IC3
outer	simpleIC3/ic3/ic3.h	/^		IC3 * outer;$/;"	m	struct:SimpIC3::IC3::LessThanClause
outputs	aiger/aiger.c	/^  unsigned outputs;$/;"	m	struct:aiger_reader	file:
outputs	aiger/aiger.h	/^  aiger_symbol *outputs;	\/* [0..num_outputs[ *\/$/;"	m	struct:aiger
parent	minisat/minisat/mtl/Heap.h	/^    static inline int parent(int i) { return (i-1) >> 1; }$/;"	f	class:Minisat::Heap
parent	simpleIC3/ic3/ic3Types.h	/^	TCube * parent;$/;"	m	struct:SimpIC3::TCube
parse	minisat/minisat/utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::BoolOption
parse	minisat/minisat/utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::DoubleOption
parse	minisat/minisat/utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::Int64Option
parse	minisat/minisat/utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::IntOption
parse	minisat/minisat/utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::StringOption
parseInt	minisat/minisat/utils/ParseUtils.h	/^static int parseInt(B& in) {$/;"	f	namespace:Minisat
parseOptions	minisat/minisat/utils/Options.cc	/^void Minisat::parseOptions(int& argc, char** argv, bool strict)$/;"	f	class:Minisat
parse_DIMACS	minisat/minisat/core/Dimacs.h	/^static void parse_DIMACS(gzFile input_stream, Solver& S, bool strictp = false) {$/;"	f	namespace:Minisat
parse_DIMACS_main	minisat/minisat/core/Dimacs.h	/^static void parse_DIMACS_main(B& in, Solver& S, bool strictp = false) {$/;"	f	namespace:Minisat
peek	minisat/minisat/mtl/Map.h	/^    bool peek   (const K& k, D& d) const {$/;"	f	class:Minisat::Map
peek	minisat/minisat/mtl/Queue.h	/^    T    peek  () const { assert(first != end); return buf[first]; }$/;"	f	class:Minisat::Queue
peekMin	simpleIC3/util/VHeap.h	/^    T & peekMin(){$/;"	f	class:SimpIC3::VHeap
percolateDown	minisat/minisat/mtl/Heap.h	/^    void percolateDown(int i)$/;"	f	class:Minisat::Heap
percolateUp	minisat/minisat/mtl/Heap.h	/^    void percolateUp(int i)$/;"	f	class:Minisat::Heap
phase_saving	minisat/minisat/core/Solver.h	/^    int       phase_saving;       \/\/ Controls the level of phase saving (0=none, 1=limited, 2=full).$/;"	m	class:Minisat::Solver
pickBranchLit	minisat/minisat/core/Solver.cc	/^Lit Solver::pickBranchLit()$/;"	f	class:Solver
polarity	minisat/minisat/core/Solver.h	/^    VMap<char>          polarity;         \/\/ The preferred polarity of each variable.$/;"	m	class:Minisat::Solver
pop	minisat/minisat/core/SolverTypes.h	/^    void         pop         ()              { shrink(1); }$/;"	f	class:Minisat::Clause
pop	minisat/minisat/mtl/Queue.h	/^    void pop   () { assert(first != end); first++; if (first == buf.size()) first = 0; }$/;"	f	class:Minisat::Queue
pop	minisat/minisat/mtl/Vec.h	/^    void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }$/;"	f	class:Minisat::vec
pos	minisat/minisat/utils/ParseUtils.h	/^    int            pos;$/;"	m	class:Minisat::StreamBuffer
position	minisat/minisat/utils/ParseUtils.h	/^    int  position    () const { return pos; }$/;"	f	class:Minisat::StreamBuffer
pre	simpleIC3/ic3/ic3.h	/^	vec<Lit> pre;$/;"	m	class:SimpIC3::IC3
pre_image	simpleIC3/ic3/ic3.h	/^	bool pre_image(vec<Lit> & p, vec<int> & aiger_lits, vec<Lit> & store, vec<Lit> & store_inputs, bool optimize=true){$/;"	f	class:SimpIC3::IC3
pre_inputs	simpleIC3/ic3/ic3.h	/^	vec<Lit> pre_inputs;$/;"	m	class:SimpIC3::IC3
pre_tmp	simpleIC3/ic3/ic3.h	/^	vec<Lit> pre_tmp;$/;"	m	class:SimpIC3::IC3
prefix	minisat/Makefile	/^prefix         ?= \/usr\/local$/;"	m
preserve	simpleIC3/ic3/Ternary.h	/^	 vec<bool> preserve;$/;"	m	class:SimpIC3::Ternary
primary_inputs	simpleIC3/ic3/ic3.h	/^	vec<Var> & primary_inputs;$/;"	m	class:SimpIC3::IC3
primary_inputs	simpleIC3/ic3/ic3Types.h	/^	Minisat::vec<Minisat::Lit> primary_inputs;$/;"	m	struct:SimpIC3::TCube
primes	minisat/minisat/mtl/Map.h	/^static const int primes [nprimes] = { 31, 73, 151, 313, 643, 1291, 2593, 5233, 10501, 21013, 42073, 84181, 168451, 337219, 674701, 1349473, 2699299, 5398891, 10798093, 21596719, 43193641, 86387383, 172775299, 345550609, 691101253 };$/;"	m	namespace:Minisat
printCEX	simpleIC3/ic3/ic3.h	/^	void printCEX(TCube * c){$/;"	f	class:SimpIC3::IC3
printFrameSizes	simpleIC3/ic3/ic3.h	/^	void printFrameSizes(){$/;"	f	class:SimpIC3::IC3
printFrames	simpleIC3/ic3/ic3.h	/^	void printFrames(bool details=false){$/;"	f	class:SimpIC3::IC3
printInput	simpleIC3/ic3/ic3.h	/^		void printInput(vec<Lit> & input, bool force_print=false){$/;"	f	class:SimpIC3::IC3
printLatches	simpleIC3/ic3/ic3.h	/^		void printLatches(vec<Lit> & latches,bool out, bool force_print=false){$/;"	f	class:SimpIC3::IC3
printStats	minisat/minisat/core/Solver.cc	/^void Solver::printStats() const$/;"	f	class:Solver
printStats	simpleIC3/ic3/ic3.h	/^	void printStats(){$/;"	f	class:SimpIC3::IC3
printTCube	simpleIC3/ic3/ic3.h	/^	void printTCube(TCube * t, bool force_print=false, bool print_input=true){$/;"	f	class:SimpIC3::IC3
printUsageAndExit	minisat/minisat/utils/Options.cc	/^void Minisat::printUsageAndExit (int \/*argc*\/, char** argv, bool verbose)$/;"	f	class:Minisat
priority	simpleIC3/ic3/Ternary.h	/^	 vec<int> * priority;$/;"	m	class:SimpIC3::Ternary
priority	simpleIC3/ic3/ic3.h	/^	vec<int> priority;$/;"	m	class:SimpIC3::IC3
progressEstimate	minisat/minisat/core/Solver.cc	/^double Solver::progressEstimate() const$/;"	f	class:Solver
progress_estimate	minisat/minisat/core/Solver.h	/^    double              progress_estimate;\/\/ Set by 'search()'.$/;"	m	class:Minisat::Solver
propagate	minisat/minisat/core/Solver.cc	/^CRef Solver::propagate()$/;"	f	class:Solver
propagate	simpleIC3/ic3/Ternary.cpp	/^	 bool  Ternary::propagate( unsigned lit){$/;"	f	class:Ternary
propagateClauses	simpleIC3/ic3/ic3.h	/^	bool propagateClauses(){$/;"	f	class:SimpIC3::IC3
propagation_budget	minisat/minisat/core/Solver.h	/^    int64_t             propagation_budget; \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver
propagations	minisat/minisat/core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
property_coi	simpleIC3/ic3/ic3.h	/^	Bitset property_coi;$/;"	m	class:SimpIC3::IC3
public	aiger/aiger.c	/^  aiger public;$/;"	m	struct:aiger_private	file:
push	minisat/minisat/mtl/Vec.h	/^    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); new (&data[sz++]) T(elem); }$/;"	f	class:Minisat::vec
push	minisat/minisat/mtl/Vec.h	/^    void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }$/;"	f	class:Minisat::vec
push_	minisat/minisat/mtl/Vec.h	/^    void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }$/;"	f	class:Minisat::vec
qhead	minisat/minisat/core/Solver.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).$/;"	m	class:Minisat::Solver
ra	minisat/minisat/core/SolverTypes.h	/^    RegionAllocator<uint32_t> ra;$/;"	m	class:Minisat::ClauseAllocator
randomShuffle	minisat/minisat/mtl/Rnd.h	/^static void randomShuffle(double& seed, vec<T>& xs)$/;"	f	namespace:Minisat
randomShuffle	minisat/minisat/mtl/Rnd.h	/^static void randomShuffle(double& seed, vec<vec<T> >& xs)$/;"	f	namespace:Minisat
random_seed	minisat/minisat/core/Solver.h	/^    double    random_seed;$/;"	m	class:Minisat::Solver
random_var_freq	minisat/minisat/core/Solver.h	/^    double    random_var_freq;$/;"	m	class:Minisat::Solver
range	minisat/minisat/utils/Options.h	/^    DoubleRange range;$/;"	m	class:Minisat::DoubleOption
range	minisat/minisat/utils/Options.h	/^    Int64Range range;$/;"	m	class:Minisat::Int64Option
range	minisat/minisat/utils/Options.h	/^    IntRange range;$/;"	m	class:Minisat::IntOption
readClause	minisat/minisat/core/Dimacs.h	/^static void readClause(B& in, Solver& S, vec<Lit>& lits) {$/;"	f	namespace:Minisat
reason	minisat/minisat/core/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::Solver::VarData
reason	minisat/minisat/core/Solver.h	/^inline CRef Solver::reason(Var x) const { return vardata[x].reason; }$/;"	f	class:Minisat::Solver
rebuildOrderHeap	minisat/minisat/core/Solver.cc	/^void Solver::rebuildOrderHeap()$/;"	f	class:Solver
reduce	simpleIC3/ic3/Ternary.cpp	/^	void Ternary::reduce(vec<lbool>& latch_assignment,vec<lbool>& primary_input_assignments, vec<int> & to_preserve){$/;"	f	class:Ternary
reduceDB	minisat/minisat/core/Solver.cc	/^void Solver::reduceDB()$/;"	f	class:Solver
reduceDB_lt	minisat/minisat/core/Solver.cc	/^    reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}$/;"	f	struct:reduceDB_lt
reduceDB_lt	minisat/minisat/core/Solver.cc	/^struct reduceDB_lt { $/;"	s	file:
reencode	simpleIC3/aiglib/aiglib.h	/^	void reencode(){$/;"	f	class:aiglib::Circuit
ref	simpleIC3/ic3/ic3Types.h	/^	void ref(){$/;"	f	struct:SimpIC3::TCube
refs	simpleIC3/ic3/ic3Types.h	/^	int refs=0;$/;"	m	struct:SimpIC3::TCube
rehash	minisat/minisat/mtl/Map.h	/^    void    rehash () {$/;"	f	class:Minisat::Map
rel	minisat/minisat/core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon5
releaseClause	simpleIC3/ic3/ic3.h	/^	void releaseClause(Lit l){$/;"	f	class:SimpIC3::IC3
releaseVar	minisat/minisat/core/Solver.cc	/^void Solver::releaseVar(Lit l)$/;"	f	class:Solver
releaseVar	minisat/minisat/simp/SimpSolver.cc	/^void SimpSolver::releaseVar(Lit l)$/;"	f	class:SimpSolver
released_vars	minisat/minisat/core/Solver.h	/^    vec<Var>            released_vars;$/;"	m	class:Minisat::Solver
reloc	minisat/minisat/core/SolverTypes.h	/^    void reloc(CRef& cr, ClauseAllocator& to)$/;"	f	class:Minisat::ClauseAllocator
relocAll	minisat/minisat/core/Solver.cc	/^void Solver::relocAll(ClauseAllocator& to)$/;"	f	class:Solver
relocAll	minisat/minisat/simp/SimpSolver.cc	/^void SimpSolver::relocAll(ClauseAllocator& to)$/;"	f	class:SimpSolver
relocate	minisat/minisat/core/SolverTypes.h	/^    void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }$/;"	f	class:Minisat::Clause
relocation	minisat/minisat/core/SolverTypes.h	/^    CRef         relocation  ()      const   { return data[0].rel; }$/;"	f	class:Minisat::Clause
reloced	minisat/minisat/core/SolverTypes.h	/^        unsigned reloced   : 1;$/;"	m	struct:Minisat::Clause::__anon4
reloced	minisat/minisat/core/SolverTypes.h	/^    bool         reloced     ()      const   { return header.reloced; }$/;"	f	class:Minisat::Clause
remainingTCubes	simpleIC3/ic3/ic3Types.h	/^	static long remainingTCubes(){$/;"	f	struct:SimpIC3::TCube
remaining_tcubes	simpleIC3/ic3/ic3Types.cpp	/^long SimpIC3::TCube::remaining_tcubes=0;$/;"	m	class:SimpIC3::TCube	file:
remaining_tcubes	simpleIC3/ic3/ic3Types.h	/^	static long remaining_tcubes;$/;"	m	struct:SimpIC3::TCube
remove	minisat/minisat/core/SolverTypes.h	/^    void     remove      (CRef cr)            { map.remove(cr); }$/;"	f	class:Minisat::CMap
remove	minisat/minisat/mtl/Alg.h	/^static inline void remove(V& ts, const T& t)$/;"	f	namespace:Minisat
remove	minisat/minisat/mtl/Heap.h	/^    void remove(K k)$/;"	f	class:Minisat::Heap
remove	minisat/minisat/mtl/Map.h	/^    void remove(const K& k) {$/;"	f	class:Minisat::Map
removeClause	minisat/minisat/core/Solver.cc	/^void Solver::removeClause(CRef cr) {$/;"	f	class:Solver
removeClause	minisat/minisat/simp/SimpSolver.cc	/^void SimpSolver::removeClause(CRef cr)$/;"	f	class:SimpSolver
removeMin	minisat/minisat/mtl/Heap.h	/^    K removeMin()$/;"	f	class:Minisat::Heap
removeMin	simpleIC3/util/VHeap.h	/^    T & removeMin(){$/;"	f	class:SimpIC3::VHeap
removeSatisfied	minisat/minisat/core/Solver.cc	/^void Solver::removeSatisfied(vec<CRef>& cs)$/;"	f	class:Solver
remove_satisfied	minisat/minisat/core/Solver.h	/^    bool                remove_satisfied; \/\/ Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.$/;"	m	class:Minisat::Solver
reserve	minisat/minisat/mtl/IntMap.h	/^        void     reserve(K key)              { map.growTo(index(key)+1); }$/;"	f	class:Minisat::IntMap
reserve	minisat/minisat/mtl/IntMap.h	/^        void     reserve(K key, V pad)       { map.growTo(index(key)+1, pad); }$/;"	f	class:Minisat::IntMap
reset	aiger/aiger.h	/^  unsigned next, reset;		\/* used only for latches *\/$/;"	m	struct:aiger_symbol
resets	simpleIC3/ic3/ic3.h	/^	vec<lbool> & resets;$/;"	m	class:SimpIC3::IC3
resize	simpleIC3/aiglib/Word.h	/^	Word resize(int newsize, Literal defaultVal = False){$/;"	f	class:Word
restart_first	minisat/minisat/core/Solver.h	/^    int       restart_first;      \/\/ The initial restart limit.                                                                (default 100)$/;"	m	class:Minisat::Solver
restart_inc	minisat/minisat/core/Solver.h	/^    double    restart_inc;        \/\/ The factor with which the restart limit is multiplied in each restart.                    (default 1.5)$/;"	m	class:Minisat::Solver
rhs0	aiger/aiger.h	/^  unsigned rhs0;		\/* as literal [0..2*maxvar+1] *\/$/;"	m	struct:aiger_and
rhs1	aiger/aiger.h	/^  unsigned rhs1;		\/* as literal [0..2*maxvar+1] *\/$/;"	m	struct:aiger_and
right	minisat/minisat/mtl/Heap.h	/^    static inline int right (int i) { return (i+1)*2; }$/;"	f	class:Minisat::Heap
rnd_decisions	minisat/minisat/core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
rnd_init_act	minisat/minisat/core/Solver.h	/^    bool      rnd_init_act;       \/\/ Initialize variable activities with a small random value.$/;"	m	class:Minisat::Solver
rnd_pol	minisat/minisat/core/Solver.h	/^    bool      rnd_pol;            \/\/ Use random polarities for branching heuristics.$/;"	m	class:Minisat::Solver
rshift	simpleIC3/aiglib/Word.h	/^	Word rshift(int arg)const{$/;"	f	class:Word
satisfied	minisat/minisat/core/Solver.cc	/^bool Solver::satisfied(const Clause& c) const {$/;"	f	class:Solver
satisfiesReset	simpleIC3/ic3/ic3.h	/^	bool satisfiesReset(Lit in_latch){$/;"	f	class:SimpIC3::IC3
search	minisat/minisat/core/Solver.cc	/^lbool Solver::search(int nof_conflicts)$/;"	f	class:Solver
seen	minisat/minisat/core/Solver.h	/^    VMap<char>          seen;$/;"	m	class:Minisat::Solver
seen	simpleIC3/ic3/Cone.h	/^	vec<bool> seen;$/;"	m	class:SimpIC3::ConeOfInfluence
seen	simpleIC3/ic3/Ternary.h	/^	 vec<bool> seen;$/;"	m	class:SimpIC3::Ternary
seen_subsume	simpleIC3/ic3/ic3.h	/^	vec<char> seen_subsume;$/;"	m	class:SimpIC3::IC3
selectionSort	minisat/minisat/mtl/Sort.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f	namespace:Minisat
selectionSort	minisat/minisat/mtl/Sort.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat
set	simpleIC3/util/Bitset.h	/^    inline void set(int index){$/;"	f	class:SimpIC3::Bitset
setConfBudget	minisat/minisat/core/Solver.h	/^inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }$/;"	f	class:Minisat::Solver
setDecisionVar	minisat/minisat/core/Solver.h	/^inline void     Solver::setDecisionVar(Var v, bool b) $/;"	f	class:Minisat::Solver
setFrozen	minisat/minisat/simp/SimpSolver.h	/^inline void SimpSolver::setFrozen    (Var v, bool b) { frozen[v] = (char)b; if (use_simplification && !b) { updateElimHeap(v); } }$/;"	f	class:Minisat::SimpSolver
setHelpPrefixStr	minisat/minisat/utils/Options.cc	/^void Minisat::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }$/;"	f	class:Minisat
setLatchReset	simpleIC3/aiglib/aiglib.h	/^	void setLatchReset(Literal latch, Value initialValue = Value::False){$/;"	f	class:aiglib::Circuit
setPolarity	minisat/minisat/core/Solver.h	/^inline void     Solver::setPolarity   (Var v, lbool b){ user_pol[v] = b; }$/;"	f	class:Minisat::Solver
setPropBudget	minisat/minisat/core/Solver.h	/^inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }$/;"	f	class:Minisat::Solver
setUsageHelp	minisat/minisat/utils/Options.cc	/^void Minisat::setUsageHelp      (const char* str){ Option::getUsageString() = str; }$/;"	f	class:Minisat
setX86FPUPrecision	minisat/minisat/utils/System.cc	/^void Minisat::setX86FPUPrecision()$/;"	f	class:Minisat
shrink	minisat/minisat/core/SolverTypes.h	/^    void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }$/;"	f	class:Minisat::Clause
shrink	minisat/minisat/mtl/Vec.h	/^    void     shrink   (Size nelems)  { assert(nelems <= sz); for (Size i = 0; i < nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:Minisat::vec
shrink_	minisat/minisat/mtl/Vec.h	/^    void     shrink_  (Size nelems)  { assert(nelems <= sz); sz -= nelems; }$/;"	f	class:Minisat::vec
sigTerm	minisat/minisat/utils/System.cc	/^void Minisat::sigTerm(void handler(int))$/;"	f	class:Minisat
sign	minisat/minisat/core/SolverTypes.h	/^inline  bool sign      (Lit p)              { return p.x & 1; }$/;"	f	namespace:Minisat
sign	simpleIC3/aiglib/aiglib.h	/^inline bool sign(Literal p) {$/;"	f	namespace:aiglib
simpDB_assigns	minisat/minisat/core/Solver.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execution of 'simplify()'.$/;"	m	class:Minisat::Solver
simpDB_props	minisat/minisat/core/Solver.h	/^    int64_t             simpDB_props;     \/\/ Remaining number of propagations that must be made before next execution of 'simplify()'.$/;"	m	class:Minisat::Solver
simp_garbage_frac	minisat/minisat/simp/SimpSolver.h	/^    double  simp_garbage_frac; \/\/ A different limit for when to issue a GC during simplification (Also see 'garbage_frac').$/;"	m	class:Minisat::SimpSolver
simplify	minisat/minisat/core/Solver.cc	/^bool Solver::simplify()$/;"	f	class:Solver
simulate	simpleIC3/ic3/Ternary.cpp	/^	bool  Ternary::simulate(int input_var,lbool assign, vec<bool> & preserve ){$/;"	f	class:Ternary
size	aiger/aiger.h	/^  unsigned size, * lits;	\/* used only for justice *\/$/;"	m	struct:aiger_symbol
size	minisat/minisat/core/SolverTypes.h	/^        unsigned size      : 27; }                        header;$/;"	m	struct:Minisat::Clause::__anon4
size	minisat/minisat/core/SolverTypes.h	/^    int          size        ()      const   { return header.size; }$/;"	f	class:Minisat::Clause
size	minisat/minisat/core/SolverTypes.h	/^    int      size        ()                const      { return map.elems(); }$/;"	f	class:Minisat::CMap
size	minisat/minisat/core/SolverTypes.h	/^    uint32_t size      () const      { return ra.size(); }$/;"	f	class:Minisat::ClauseAllocator
size	minisat/minisat/mtl/Alloc.h	/^    uint32_t size      () const      { return sz; }$/;"	f	class:Minisat::RegionAllocator
size	minisat/minisat/mtl/Heap.h	/^    int  size      ()          const { return heap.size(); }$/;"	f	class:Minisat::Heap
size	minisat/minisat/mtl/IntMap.h	/^        int      size        (void)      const  { return xs.size(); }$/;"	f	class:Minisat::IntSet
size	minisat/minisat/mtl/Map.h	/^    int        size;$/;"	m	class:Minisat::Map
size	minisat/minisat/mtl/Queue.h	/^    int  size  () const { return (end >= first) ? end - first : end - first + buf.size(); }$/;"	f	class:Minisat::Queue
size	minisat/minisat/mtl/Vec.h	/^    Size     size     (void) const   { return sz; }$/;"	f	class:Minisat::vec
size	minisat/minisat/utils/ParseUtils.h	/^    int            size;$/;"	m	class:Minisat::StreamBuffer
size	simpleIC3/aiglib/Word.h	/^	int size() const{$/;"	f	class:Word
size	simpleIC3/util/Bitset.h	/^    int  size  () const { return sz; }$/;"	f	class:SimpIC3::Bitset
size	simpleIC3/util/VHeap.h	/^    int size(){$/;"	f	class:SimpIC3::VHeap
size_ands	aiger/aiger.c	/^  unsigned size_ands;$/;"	m	struct:aiger_private	file:
size_bad	aiger/aiger.c	/^  unsigned size_bad;$/;"	m	struct:aiger_private	file:
size_buffer	aiger/aiger.c	/^  unsigned size_buffer;$/;"	m	struct:aiger_reader	file:
size_coi	aiger/aiger.c	/^  unsigned size_coi;$/;"	m	struct:aiger_private	file:
size_comments	aiger/aiger.c	/^  unsigned size_comments;$/;"	m	struct:aiger_private	file:
size_constraints	aiger/aiger.c	/^  unsigned size_constraints;$/;"	m	struct:aiger_private	file:
size_fairness	aiger/aiger.c	/^  unsigned size_fairness;$/;"	m	struct:aiger_private	file:
size_inputs	aiger/aiger.c	/^  unsigned size_inputs;$/;"	m	struct:aiger_private	file:
size_justice	aiger/aiger.c	/^  unsigned size_justice;$/;"	m	struct:aiger_private	file:
size_latches	aiger/aiger.c	/^  unsigned size_latches;$/;"	m	struct:aiger_private	file:
size_outputs	aiger/aiger.c	/^  unsigned size_outputs;$/;"	m	struct:aiger_private	file:
size_types	aiger/aiger.c	/^  unsigned size_types;$/;"	m	struct:aiger_private	file:
skipLine	minisat/minisat/utils/ParseUtils.h	/^static void skipLine(B& in) {$/;"	f	namespace:Minisat
skipWhitespace	minisat/minisat/utils/ParseUtils.h	/^static void skipWhitespace(B& in) {$/;"	f	namespace:Minisat
slice	simpleIC3/aiglib/Word.h	/^	Word slice(int lower, int upper)const{$/;"	f	class:Word
smudge	minisat/minisat/core/SolverTypes.h	/^    void  smudge    (const K& idx){$/;"	f	class:Minisat::OccLists
solve	minisat/minisat/core/Solver.h	/^inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	minisat/minisat/core/Solver.h	/^inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	minisat/minisat/core/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	minisat/minisat/core/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	minisat/minisat/core/Solver.h	/^inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::solve        (                     bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver
solve	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p       ,        bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver
solve	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p, Lit q,        bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver
solve	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p, Lit q, Lit r, bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver
solve	minisat/minisat/simp/SimpSolver.h	/^inline bool SimpSolver::solve        (const vec<Lit>& assumps, bool do_simp, bool turn_off_simp){ $/;"	f	class:Minisat::SimpSolver
solve	simpleIC3/ic3/ic3.h	/^	bool solve(vec<Lit> & property,vec<int> & aiger_property,bool property_needs_preimage = true){$/;"	f	class:SimpIC3::IC3
solveAtFrame	simpleIC3/ic3/ic3.h	/^	bool solveAtFrame(vec<Lit> & extra_assumptions, int frame){$/;"	f	class:SimpIC3::IC3
solveLimited	minisat/minisat/core/Solver.h	/^inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }$/;"	f	class:Minisat::Solver
solveLimited	minisat/minisat/simp/SimpSolver.h	/^inline lbool SimpSolver::solveLimited (const vec<Lit>& assumps, bool do_simp, bool turn_off_simp){ $/;"	f	class:Minisat::SimpSolver
solve_	minisat/minisat/core/Solver.cc	/^lbool Solver::solve_()$/;"	f	class:Solver
solve_	minisat/minisat/simp/SimpSolver.cc	/^lbool SimpSolver::solve_(bool do_simp, bool turn_off_simp)$/;"	f	class:SimpSolver
solver	minisat/minisat/core/Main.cc	/^static Solver* solver;$/;"	v	file:
solver	minisat/minisat/simp/Main.cc	/^static Solver* solver;$/;"	v	file:
solves	minisat/minisat/core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
sort	minisat/minisat/mtl/Sort.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f	namespace:Minisat
sort	minisat/minisat/mtl/Sort.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f	namespace:Minisat
sort	minisat/minisat/mtl/Sort.h	/^template <class T> void sort(vec<T>& v) {$/;"	f	namespace:Minisat
sort	minisat/minisat/mtl/Sort.h	/^void sort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat
sortByPriority	simpleIC3/ic3/ic3.h	/^	void sortByPriority(const vec<Lit> & cube, vec<int> &order, int frame)$/;"	f	class:SimpIC3::IC3
sort_by_size	simpleIC3/ic3/ic3.h	/^	void sort_by_size(vec<Lit> & clauses){$/;"	f	class:SimpIC3::IC3
start	aiger/aiger.c	/^  char *start;$/;"	m	struct:aiger_buffer	file:
start_of_activation_vars	simpleIC3/ic3/ic3.h	/^	Var start_of_activation_vars=var_Undef;$/;"	m	class:SimpIC3::IC3
start_of_in_latches	simpleIC3/ic3/ic3.h	/^	Var start_of_in_latches=var_Undef;$/;"	m	class:SimpIC3::IC3
start_of_out_latches	simpleIC3/ic3/ic3.h	/^	Var start_of_out_latches=var_Undef;$/;"	m	class:SimpIC3::IC3
starts	minisat/minisat/core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
state	aiger/aiger.c	/^  void *state;$/;"	m	struct:aiger_reader	file:
stats_coi_lits_removed	simpleIC3/ic3/ic3.h	/^	long stats_coi_lits_removed=0;$/;"	m	class:SimpIC3::IC3
stats_generalize_lits_removed	simpleIC3/ic3/ic3.h	/^	long stats_generalize_lits_removed =0;$/;"	m	class:SimpIC3::IC3
stats_subsumed_clauses_removed	simpleIC3/ic3/ic3.h	/^	long stats_subsumed_clauses_removed=0;$/;"	m	class:SimpIC3::IC3
stats_ternary_lits_removed	simpleIC3/ic3/ic3.h	/^	long stats_ternary_lits_removed=0;$/;"	m	class:SimpIC3::IC3
store	simpleIC3/aiglib/aiglib.h	/^	std::vector<Literal> store;$/;"	m	class:aiglib::Circuit
strengthen	minisat/minisat/core/SolverTypes.h	/^inline void Clause::strengthen(Lit p)$/;"	f	class:Minisat::Clause
strengthenClause	minisat/minisat/simp/SimpSolver.cc	/^bool SimpSolver::strengthenClause(CRef cr, Lit l)$/;"	f	class:SimpSolver
sub_t	simpleIC3/ic3/ic3.h	/^	vec<Lit> sub_t;$/;"	m	class:SimpIC3::IC3
substitute	minisat/minisat/simp/SimpSolver.cc	/^bool SimpSolver::substitute(Var v, Lit x)$/;"	f	class:SimpSolver
subsumes	minisat/minisat/core/SolverTypes.h	/^inline Lit Clause::subsumes(const Clause& other) const$/;"	f	class:Minisat::Clause
subsumption_lim	minisat/minisat/simp/SimpSolver.h	/^    int     subsumption_lim;   \/\/ Do not check if subsumption against a clause larger than this. -1 means no limit.$/;"	m	class:Minisat::SimpSolver
subsumption_queue	minisat/minisat/simp/SimpSolver.h	/^    Queue<CRef>         subsumption_queue;$/;"	m	class:Minisat::SimpSolver
sz	minisat/minisat/mtl/Alloc.h	/^    uint32_t  sz;$/;"	m	class:Minisat::RegionAllocator
sz	minisat/minisat/mtl/Vec.h	/^    Size sz;$/;"	m	class:Minisat::vec
sz	simpleIC3/util/Bitset.h	/^    int sz;$/;"	m	class:SimpIC3::Bitset
sz	simpleIC3/util/VHeap.h	/^    int sz;$/;"	m	class:SimpIC3::VHeap
table	minisat/minisat/mtl/Map.h	/^    vec<Pair>* table;$/;"	m	class:Minisat::Map
ternary	simpleIC3/ic3/ic3.h	/^	Ternary * ternary=nullptr;$/;"	m	class:SimpIC3::IC3
ternary_assign	simpleIC3/ic3/ic3.h	/^	vec<lbool> ternary_assign;$/;"	m	class:SimpIC3::IC3
ternary_inputs	simpleIC3/ic3/ic3.h	/^	vec<lbool>ternary_inputs;$/;"	m	class:SimpIC3::IC3
ternary_preserve	simpleIC3/ic3/ic3.h	/^	vec<int> ternary_preserve;$/;"	m	class:SimpIC3::IC3
thaw	minisat/minisat/simp/SimpSolver.h	/^inline void SimpSolver::thaw(){$/;"	f	class:Minisat::SimpSolver
tmp	simpleIC3/aiglib/aiglib.h	/^	std::vector<Literal> tmp;$/;"	m	class:aiglib::Circuit
tmp_assumps	simpleIC3/ic3/ic3.h	/^	vec<Lit> tmp_assumps;$/;"	m	class:SimpIC3::IC3
tmp_asummptions	simpleIC3/ic3/ic3.h	/^	vec<Lit> tmp_asummptions;$/;"	m	class:SimpIC3::IC3
tmp_c	simpleIC3/ic3/ic3.h	/^	vec<Lit> tmp_c;$/;"	m	class:SimpIC3::IC3
tmp_clause	simpleIC3/ic3/ic3.h	/^	vec<Lit> tmp_clause;$/;"	m	class:SimpIC3::IC3
tmp_seen	simpleIC3/ic3/ic3.h	/^	vec<int> tmp_seen;$/;"	m	class:SimpIC3::IC3
toDimacs	minisat/minisat/core/Solver.cc	/^void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)$/;"	f	class:Solver
toDimacs	minisat/minisat/core/Solver.cc	/^void Solver::toDimacs(FILE* f, const vec<Lit>& assumps)$/;"	f	class:Solver
toDimacs	minisat/minisat/core/Solver.cc	/^void Solver::toDimacs(const char *file, const vec<Lit>& assumps)$/;"	f	class:Solver
toDimacs	minisat/minisat/core/Solver.h	/^inline void     Solver::toDimacs     (const char* file){ vec<Lit> as; toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toDimacs	minisat/minisat/core/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p){ vec<Lit> as; as.push(p); toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toDimacs	minisat/minisat/core/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q){ vec<Lit> as; as.push(p); as.push(q); toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toDimacs	minisat/minisat/core/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.push(p); as.push(q); as.push(r); toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toInt	minisat/minisat/core/SolverTypes.h	/^inline  int  toInt     (Lit p)              { return p.x; } $/;"	f	namespace:Minisat
toInt	minisat/minisat/core/SolverTypes.h	/^inline  int  toInt     (Var v)              { return v; } $/;"	f	namespace:Minisat
toInt	minisat/minisat/core/SolverTypes.h	/^inline int   toInt  (lbool l) { return l.value; }$/;"	f	namespace:Minisat
toInt	simpleIC3/aiglib/aiglib.h	/^	unsigned toInt() const{$/;"	f	struct:aiglib::Literal
toLbool	minisat/minisat/core/SolverTypes.h	/^inline lbool toLbool(int   v) { return lbool((uint8_t)v);  }$/;"	f	namespace:Minisat
toLit	minisat/minisat/core/SolverTypes.h	/^inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } $/;"	f	namespace:Minisat
toVec	minisat/minisat/mtl/IntMap.h	/^                 toVec       ()          const  { return xs; }$/;"	f	class:Minisat::IntSet
to_update	simpleIC3/ic3/Ternary.h	/^	  vec<int> to_update;$/;"	m	class:SimpIC3::Ternary
toggle	simpleIC3/util/Bitset.h	/^    inline void toggle(int index){$/;"	f	class:SimpIC3::Bitset
top_buffer	aiger/aiger.c	/^  unsigned top_buffer;$/;"	m	struct:aiger_reader	file:
tot_literals	minisat/minisat/core/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
total_tcubes	simpleIC3/ic3/ic3Types.cpp	/^long SimpIC3::TCube::total_tcubes=0;$/;"	m	class:SimpIC3::TCube	file:
total_tcubes	simpleIC3/ic3/ic3Types.h	/^	static long total_tcubes;$/;"	m	struct:SimpIC3::TCube
touched	minisat/minisat/simp/SimpSolver.h	/^    VMap<char>          touched;$/;"	m	class:Minisat::SimpSolver
trail	minisat/minisat/core/Solver.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:Minisat::Solver
trailBegin	minisat/minisat/core/Solver.h	/^inline TrailIterator  Solver::trailBegin  () const { return TrailIterator(&trail[0]); }$/;"	f	class:Minisat::Solver
trailEnd	minisat/minisat/core/Solver.h	/^inline TrailIterator  Solver::trailEnd    () const { $/;"	f	class:Minisat::Solver
trail_lim	minisat/minisat/core/Solver.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels in 'trail'.$/;"	m	class:Minisat::Solver
type_name	minisat/minisat/utils/Options.h	/^    const char* type_name;$/;"	m	class:Minisat::Option
types	aiger/aiger.c	/^  aiger_type *types;		\/* [0..maxvar] *\/$/;"	m	struct:aiger_private	file:
uncheckedEnqueue	minisat/minisat/core/Solver.cc	/^void Solver::uncheckedEnqueue(Lit p, CRef from)$/;"	f	class:Solver
update	minisat/minisat/mtl/Heap.h	/^    void update(K k)$/;"	f	class:Minisat::Heap
updateElimHeap	minisat/minisat/simp/SimpSolver.h	/^inline void SimpSolver::updateElimHeap(Var v) {$/;"	f	class:Minisat::SimpSolver
use_asymm	minisat/minisat/simp/SimpSolver.h	/^    bool    use_asymm;         \/\/ Shrink clauses by asymmetric branching.$/;"	m	class:Minisat::SimpSolver
use_elim	minisat/minisat/simp/SimpSolver.h	/^    bool    use_elim;          \/\/ Perform variable elimination.$/;"	m	class:Minisat::SimpSolver
use_rcheck	minisat/minisat/simp/SimpSolver.h	/^    bool    use_rcheck;        \/\/ Check if a clause is already implied. Prett costly, and subsumes subsumptions :)$/;"	m	class:Minisat::SimpSolver
use_simplification	minisat/minisat/simp/SimpSolver.h	/^    bool                use_simplification;$/;"	m	class:Minisat::SimpSolver
user_pol	minisat/minisat/core/Solver.h	/^    VMap<lbool>         user_pol;         \/\/ The users preferred polarity of each variable.$/;"	m	class:Minisat::Solver
value	minisat/minisat/core/Solver.h	/^inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver
value	minisat/minisat/core/Solver.h	/^inline lbool    Solver::value         (Var x) const   { return assigns[x]; }$/;"	f	class:Minisat::Solver
value	minisat/minisat/core/SolverTypes.h	/^    uint8_t value;$/;"	m	class:Minisat::lbool
value	minisat/minisat/utils/Options.h	/^    bool value;$/;"	m	class:Minisat::BoolOption
value	minisat/minisat/utils/Options.h	/^    const char* value;$/;"	m	class:Minisat::StringOption
value	minisat/minisat/utils/Options.h	/^    double      value;$/;"	m	class:Minisat::DoubleOption
value	minisat/minisat/utils/Options.h	/^    int32_t  value;$/;"	m	class:Minisat::IntOption
value	minisat/minisat/utils/Options.h	/^    int64_t  value;$/;"	m	class:Minisat::Int64Option
var	minisat/minisat/core/SolverTypes.h	/^inline  int  var       (Lit p)              { return p.x >> 1; }$/;"	f	namespace:Minisat
var	simpleIC3/aiglib/aiglib.h	/^inline int var(Literal p) {$/;"	f	namespace:aiglib
varBumpActivity	minisat/minisat/core/Solver.h	/^inline void Solver::varBumpActivity(Var v) { varBumpActivity(v, var_inc); }$/;"	f	class:Minisat::Solver
varBumpActivity	minisat/minisat/core/Solver.h	/^inline void Solver::varBumpActivity(Var v, double inc) {$/;"	f	class:Minisat::Solver
varDecayActivity	minisat/minisat/core/Solver.h	/^inline void Solver::varDecayActivity() { var_inc *= (1 \/ var_decay); }$/;"	f	class:Minisat::Solver
var_Undef	minisat/minisat/core/SolverTypes.h	/^  const Var var_Undef = -1;$/;"	m	namespace:Minisat
var_Undef	minisat/minisat/core/SolverTypes.h	45;"	d
var_decay	minisat/minisat/core/Solver.h	/^    double    var_decay;$/;"	m	class:Minisat::Solver
var_inc	minisat/minisat/core/Solver.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:Minisat::Solver
vardata	minisat/minisat/core/Solver.h	/^    VMap<VarData>       vardata;          \/\/ Stores reason and level for each variable.$/;"	m	class:Minisat::Solver
vec	minisat/minisat/mtl/Vec.h	/^    explicit vec(Size size)      : data(NULL), sz(0), cap(0)    { growTo(size); }$/;"	f	class:Minisat::vec
vec	minisat/minisat/mtl/Vec.h	/^    vec()                        : data(NULL), sz(0), cap(0)    { }$/;"	f	class:Minisat::vec
vec	minisat/minisat/mtl/Vec.h	/^    vec(Size size, const T& pad) : data(NULL), sz(0), cap(0)    { growTo(size, pad); }$/;"	f	class:Minisat::vec
vec	minisat/minisat/mtl/Vec.h	/^class vec {$/;"	c	namespace:Minisat
verbosity	minisat/minisat/core/Solver.h	/^    int       verbosity;$/;"	m	class:Minisat::Solver
wasted	minisat/minisat/core/SolverTypes.h	/^    uint32_t wasted    () const      { return ra.wasted(); }$/;"	f	class:Minisat::ClauseAllocator
wasted	minisat/minisat/mtl/Alloc.h	/^    uint32_t wasted    () const      { return wasted_; }$/;"	f	class:Minisat::RegionAllocator
wasted_	minisat/minisat/mtl/Alloc.h	/^    uint32_t  wasted_;$/;"	m	class:Minisat::RegionAllocator
watches	minisat/minisat/core/Solver.h	/^                        watches;          \/\/ 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:Minisat::Solver
withinBudget	minisat/minisat/core/Solver.h	/^inline bool     Solver::withinBudget() const {$/;"	f	class:Minisat::Solver
writeToFile	simpleIC3/aiglib/aiglib.h	/^	void writeToFile(const char * file){$/;"	f	class:aiglib::Circuit
x	minisat/minisat/core/SolverTypes.h	/^    int     x;$/;"	m	struct:Minisat::Lit
x	simpleIC3/aiglib/aiglib.h	/^	unsigned x;$/;"	m	struct:aiglib::Literal
xrealloc	minisat/minisat/mtl/XAlloc.h	/^static inline void* xrealloc(void *ptr, size_t size)$/;"	f	namespace:Minisat
xs	minisat/minisat/mtl/IntMap.h	/^        vec<K>                   xs;$/;"	m	class:Minisat::IntSet
zero	simpleIC3/aiglib/Word.h	/^	Word zero(){$/;"	f	class:Word
zero	simpleIC3/util/Bitset.h	/^    void zero(){$/;"	f	class:SimpIC3::Bitset
~Bitset	simpleIC3/util/Bitset.h	/^    ~Bitset(){$/;"	f	class:SimpIC3::Bitset
~Circuit	simpleIC3/aiglib/aiglib.h	/^	~Circuit(){$/;"	f	class:aiglib::Circuit
~Map	minisat/minisat/mtl/Map.h	/^    ~Map () { delete [] table; }$/;"	f	class:Minisat::Map
~Option	minisat/minisat/utils/Options.h	/^    virtual ~Option() {}$/;"	f	class:Minisat::Option
~RegionAllocator	minisat/minisat/mtl/Alloc.h	/^    ~RegionAllocator()$/;"	f	class:Minisat::RegionAllocator
~SimpSolver	minisat/minisat/simp/SimpSolver.cc	/^SimpSolver::~SimpSolver()$/;"	f	class:SimpSolver
~Solver	minisat/minisat/core/Solver.cc	/^Solver::~Solver()$/;"	f	class:Solver
~StreamBuffer	minisat/minisat/utils/ParseUtils.h	/^    ~StreamBuffer() { free(buf); }$/;"	f	class:Minisat::StreamBuffer
~TCube	simpleIC3/ic3/ic3Types.h	/^	~TCube(){$/;"	f	struct:SimpIC3::TCube
~vec	minisat/minisat/mtl/Vec.h	/^   ~vec()                                                       { clear(true); }$/;"	f	class:Minisat::vec
